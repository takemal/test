// ==UserScript==
// @name         godfat機能拡張スクリプトv3.0
// @namespace    http://tampermonkey.net/
// @version      3.0
// @author       Tora
// @description  godfat機能拡張スクリプトv3.0
// @match        https://bc.godfat.org/*
// @grant        none
// ==/UserScript==
/*
 * ▼ 機能一覧
 * ① ガチャ間レア被り表示機能
 * ② オリジナルテーブル表示(3ガチャまで)
 * ③ 計画モード
 * ④ 昇格枠表示機能
 * ⑤ シード保存機能（日付付き）
 * ⑥ 確定列最小化
 * ⑦ 表拡張機能
 * ⑧ テーブル巻き戻し機能
 * ⑨ 赤枠/紫枠の文字色変更
 *
 * ▼ 注意事項（必ずお読みください）：
 * ・本スクリプトは個人利用を目的として作成されたものです。
 * ・本スクリプトは表示内容を補助・改善するツールであり、表示されるデータの正確性を保証するものではありません。
 * ・トラブルを避けるため、作成者無許可での再配布・転載・販売・第三者への共有は禁止とさせていただきます。
 * ・これらの注意書きを編集/削除しないでください。
 *
 * ▼ 更新履歴
 * v1.0 -   本スクリプト作成
 * v2.0 -   オリジナルテーブル導入
 * v3.0 -   計画モード導入
 */
(function () {
  'use strict';

  const currentDate = '2025/07/19';
  // ==================== 設定データ構造 ====================
  const DEFAULT_RARE = [
    'ネコ武闘家',
    'ネコマタドール',
    'ネコ探査機',
    'ネコボクサー',
    'ネコバサミ',
    'ねこ陰陽師',
    'サイキックネコ',
    'ねこ人魚',
    'ねこロッカー',
    'ブリキネコ',
    'たけうまねこ',
    'ねこガンマン',
    'ネコ魔剣士',
    'ネコアーチャー',
    'ネコ魔女',
    'ネコシャーマン',
    'ねこ占い師',
    'ねこ僧侶',
    'ねこ泥棒',
    'ねこ海賊',
    'ねこファイター',
    'ねこジュラ',
    'ネコエステ',
    'ネコ車輪',
    'ネコホッピング',
  ];
  const DEFAULT_SUPER = [
    '戦隊チャッソ',
    '戦隊ショベリン',
    '戦隊チョギントス',
    '戦隊ウチコンガ',
    '戦隊ドリラ',
    'メタルネコ',
    'にゃんこ城mini',
    'ねねこ',
    '金ネコ',
    'おかめはちもくネコ',
    'ボンボンネコ',
    '見習いスニャイパー',
    '泉のネコ女神',
    'ネコフェンシング',
    'ネコジャンパー',
    'ネコサーファー',
    'ネコトースター',
    'ネコスケート',
    'ネコバーベル',
    '窓辺の乙女ネコ',
    'ねこ寿司',
    'ネコバスたぶ',
    'ネコリンゴ',
    'ネコスイマー',
    'オタネコ',
    'ねこタツ',
    'ネコザイル',
    'ネコ番長',
    'ネコぼさつ',
  ];
  const DEFAULT_SUPER2 = [
    '泉のネコ女神',
    'ネコフェンシング',
    'ネコジャンパー',
    'ネコサーファー',
    'ネコトースター',
    'ネコスケート',
    'ネコバーベル',
    '窓辺の乙女ネコ',
    'ねこ寿司',
    'ネコバスたぶ',
    'ネコリンゴ',
    'ネコスイマー',
    'オタネコ',
    'ねこタツ',
    'ネコザイル',
    'ネコ番長',
    'ネコぼさつ',
  ];
  const DEFAULT_SUPER3 = [
    '泉のネコ女神',
    'ネコフェンシング',
    'ネコジャンパー',
    '見習いスニャイパー',
    'ボンボンネコ',
    'おかめはちもくネコ',
    'メタルネコ',
    'にゃんこ城mini',
    'ねねこ',
    '金ネコ',
    'ネコサーファー',
    'ネコトースター',
    'ネコスケート',
    'ネコバーベル',
    '窓辺の乙女ネコ',
    'ねこ寿司',
    'ネコバスたぶ',
    'ネコリンゴ',
    'ネコスイマー',
    'オタネコ',
    'ねこタツ',
    'ネコザイル',
    'ネコ番長',
    'ネコぼさつ',
  ];
  const DEFAULT_RATE = [6969, 9469, 9969, 9999];
  const DEFAULT_TWICE_RATE = [6439, 8939, 9939, 9999];
  const GACHA_CONFIG = {
    '---permanent---': {
      name: '―――恒常―――',
      disabled: true,
    },
    galaxy: {
      name: 'ギャラクシーギャルズ',
      rate: DEFAULT_RATE,
      twiceRate: DEFAULT_TWICE_RATE,
      characters: [
        DEFAULT_RARE,
        DEFAULT_SUPER,
        [
          '鉄籠のペガサ',
          '狩猟娘テルン',
          '妖賢女リリン',
          '英雄令嬢メルシュ',
          '双掌星のシシル＆コマリ',
          '冥界のカリファ',
          '宝杖のカッパーマイン',
          '召し豚のカイ',
          '猿帝のクウ',
          '雷神のサンディア',
          '風神のウィンディ',
        ],
        ['聖会長ジャンヌダルク'],
      ],
      keys: ['鉄籠のペガサ', '電脳'],
      has: '鉄籠のペガサ',
    },
    basara: {
      name: '戦国バサラーズ',
      rate: DEFAULT_RATE,
      twiceRate: DEFAULT_TWICE_RATE,
      characters: [DEFAULT_RARE, DEFAULT_SUPER, ['明智光秀', '服部半蔵', '天草四郎', '成田甲斐', '今川義元', '上杉謙信', '武田信玄', '伊達政宗', '織田信長', '前田慶次', '真田幸村'], ['宮本武蔵']],
      keys: ['明智光秀', '戦国'],
      has: '明智光秀',
    },
    dragon: {
      name: 'ドラゴンエンペラーズ',
      rate: DEFAULT_RATE,
      twiceRate: DEFAULT_TWICE_RATE,
      characters: [
        DEFAULT_RARE,
        DEFAULT_SUPER,
        [
          '砲龍ガンドロス',
          '海龍ダライアサン',
          '邪龍ヘヴィジャーク',
          '角龍グラディオス',
          '古龍ガングリオン',
          '覇龍ディオラムス',
          '竜戦機ライデン',
          '神龍かむくら',
          '竜騎士バルス',
          '聖龍メギドラ',
          '地龍ソドム',
        ],
        ['天城龍バベル'],
      ],
      keys: ['砲龍ガンドロス', 'ドラゴン'],
      has: '砲龍ガンドロス',
    },
    dynamites: {
      name: '超激ダイナマイツ',
      rate: DEFAULT_RATE,
      twiceRate: DEFAULT_TWICE_RATE,
      characters: [
        DEFAULT_RARE,
        DEFAULT_SUPER,
        ['ネコダイナザウルス', 'ネコ天狗', '召喚少年サトル', 'ラスヴォース', 'ネコクエスト', 'ねこナース', 'ねこベビー', 'ネコシュバリエ', '鬼にゃんま', 'ネコマシン', 'ネコアイス'],
        ['ワンダー・モモコ'],
      ],
      keys: ['ネコダイナザウルス', 'バラエティ'],
      has: 'ネコダイナザウルス',
    },
    souls: {
      name: 'ウルトラソウルズ',
      rate: DEFAULT_RATE,
      twiceRate: DEFAULT_TWICE_RATE,
      characters: [
        DEFAULT_RARE,
        DEFAULT_SUPER,
        ['花咲かじいさん', 'いっすん法師', '舌切りすずめ', 'きんたろう', 'さるかに合戦', 'カチカチヤマンズ', 'かぐやひめ', 'かさじぞう', 'ももたろう', 'ツルの恩返し', 'うらしまタロウ'],
        ['うしわか丸'],
      ],
      keys: ['花咲かじいさん', '古代'],
      has: '花咲かじいさん',
    },
    dark: {
      name: 'ダークヒーローズ',
      rate: DEFAULT_RATE,
      twiceRate: DEFAULT_TWICE_RATE,
      characters: [
        DEFAULT_RARE,
        DEFAULT_SUPER,
        [
          '特命機動アクセル',
          'サンダージャック',
          '白騎士キュクロプス',
          'マッドシューター・サキ',
          '亡者探偵ヴィグラー',
          '天誅ハヤブサ',
          '呪術師デスピエロ',
          'ホワイトラビット',
          'キャットマンダディ',
          '西園寺メカ子',
          'アキラ',
        ],
        ['超越科学者ヘヴン博士'],
      ],
      keys: ['特命機動アクセル', '救世主'],
      has: '特命機動アクセル',
    },
    lugas: {
      name: 'ルガ族',
      rate: DEFAULT_RATE,
      twiceRate: DEFAULT_TWICE_RATE,
      characters: [DEFAULT_RARE, DEFAULT_SUPER, ['マモルガ', 'カオルガ', 'オコルガ', 'オイルガ', 'ノビルガ', 'トゲルガ', 'バララガ', 'テコルガ', 'クビルガ', 'アシルガ', 'ネコルガ'], ['レジェルガ']],
      keys: ['マモルガ', 'ねこなのか'],
      has: 'マモルガ',
    },
    zeus: {
      name: 'ギガントゼウス',
      rate: DEFAULT_RATE,
      twiceRate: DEFAULT_TWICE_RATE,
      characters: [
        DEFAULT_RARE,
        DEFAULT_SUPER,
        ['光翼神イシス', '堕天神ルシファー', '冥界神ハデス', '時空神クロノス', '海王神ポセイドン', '繁栄神ガネーシャ', '太陽神アマテラス', '美女神アフロディーテ', '守護神アヌビス', '天空神ゼウス'],
        ['創造神ガイア'],
      ],
      keys: ['光翼神イシス', '神'],
      has: '光翼神イシス',
    },
    iron: {
      name: 'アイアンウォーズ',
      rate: DEFAULT_RATE,
      twiceRate: DEFAULT_TWICE_RATE,
      characters: [
        DEFAULT_RARE,
        [
          '泉のネコ女神',
          '戦隊チャッソ',
          '戦隊ショベリン',
          '戦隊チョギントス',
          '戦隊ウチコンガ',
          '戦隊ドリラ',
          'ネコフェンシング',
          'ネコジャンパー',
          'メタルネコ',
          'にゃんこ城mini',
          'ねねこ',
          '金ネコ',
          'おかめはちもくネコ',
          'ボンボンネコ',
          '見習いスニャイパー',
          'ネコサーファー',
          'ネコトースター',
          'ネコスケート',
          'ネコバーベル',
          '窓辺の乙女ネコ',
          'ねこ寿司',
          'ネコバスたぶ',
          'ネコリンゴ',
          'ネコスイマー',
          'オタネコ',
          'ねこタツ',
          'ネコザイル',
          'ネコ番長',
          'ネコぼさつ',
        ],
        [
          '曲射砲台ランチャーズ',
          '建築兵団スフィンクス',
          '周遊芸団カルーセルズ',
          '超竜戦機デス・トロイ',
          '空中商会コロンブス',
          '温泉天国テルマエ',
          '観測兵器ガリレオ',
          '飛空襲撃ボンバーズ',
          '古代軍船ガレーズ',
          '帝国陸軍カタパルズ',
        ],
        ['終末兵器ムー'],
      ],
      keys: ['曲射砲台ランチャーズ', 'ゾンビ'],
      has: '曲射砲台ランチャーズ',
    },
    pixies: {
      name: 'エレメンタルピクシーズ',
      rate: DEFAULT_RATE,
      twiceRate: DEFAULT_TWICE_RATE,
      characters: [
        DEFAULT_RARE,
        [
          '戦隊チャッソ',
          '戦隊ショベリン',
          '戦隊チョギントス',
          '戦隊ウチコンガ',
          '戦隊ドリラ',
          'メタルネコ',
          'にゃんこ城mini',
          'ねねこ',
          '金ネコ',
          'おかめはちもくネコ',
          'ボンボンネコ',
          '見習いスニャイパー',
          ...DEFAULT_SUPER2,
        ],
        ['鉄の精霊カッチン', '氷の精霊フリズ', '火の精霊メララ', '水の精霊ミズリィ', '風の精霊エアル', '雷の精霊ボルト', '石の精霊ゴロー', '闇の精霊ヤミィ'],
        ['幻の精霊ルミナ'],
      ],
      keys: ['鉄の精霊カッチン', '精霊'],
      has: '鉄の精霊カッチン',
    },
    galmons: {
      name: 'ギャルズモンスターズ',
      rate: DEFAULT_RATE,
      twiceRate: DEFAULT_TWICE_RATE,
      characters: [
        DEFAULT_RARE,
        [
          '泉のネコ女神',
          '戦隊チャッソ',
          '戦隊ショベリン',
          '戦隊チョギントス',
          '戦隊ウチコンガ',
          '戦隊ドリラ',
          'ネコフェンシング',
          'メタルネコ',
          'にゃんこ城mini',
          'ねねこ',
          '金ネコ',
          'おかめはちもくネコ',
          'ボンボンネコ',
          '見習いスニャイパー',
          'ネコジャンパー',
          'ネコサーファー',
          'ネコトースター',
          'ネコスケート',
          'ネコバーベル',
          '窓辺の乙女ネコ',
          'ねこ寿司',
          'ネコバスたぶ',
          'ネコリンゴ',
          'ネコスイマー',
          'オタネコ',
          'ねこタツ',
          'ネコザイル',
          'ネコ番長',
          'ネコぼさつ',
        ],
        ['忍者娘トモエ', '女神ベガ', '冒険家カンナ', 'ゾンビ娘ヴェルヴェーヌ', '狼娘ディル', 'ミイラ娘レイカ', '人魚娘ルリィ', '狐娘ヒメユリ'],
        ['京坂七穂'],
      ],
      keys: ['忍者娘トモエ', '異世界'],
      has: '忍者娘トモエ',
    },
    '---busters---': {
      name: '―――バスターズ―――',
      disabled: true,
    },
    redbusters: {
      name: 'レッドバスターズ',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        DEFAULT_SUPER3,
        [
          '邪龍ヘヴィジャーク',
          'マッドシューター・サキ',
          '古代軍船ガレーズ',
          '猫飯拳パイパイ',
          'ホワイトラビット',
          'ももたろう',
          '伊達政宗',
          '猿帝のクウ',
          '竜戦機ライデン',
          '神龍かむくら',
          '雷神のサンディア',
          'ネコマシン',
          'ネコアイス',
        ],
        [],
      ],
      keys: ['赤い'],
      has: '猫飯拳パイパイ',
    },
    airbusters: {
      name: 'エアバスターズ',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        DEFAULT_SUPER3,
        ['閃雷機兵レイ', 'キャットマンダディ', 'ねこナース', 'ツルの恩返し', '宝杖のカッパーマイン', '召し豚のカイ', '聖龍メギドラ', '地龍ソドム', '風神のウィンディ', 'ねこベビー'],
        [],
      ],
      keys: ['エア'],
      has: '閃雷機兵レイ',
    },
    metalbusters: {
      name: 'メタルバスターズ',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        [
          ...Array(3).fill('バレンタインねねこ'),
          ...Array(3).fill('イースターねねこ'),
          ...Array(3).fill('大掃除ねねこ'),
          ...Array(3).fill('夏色ねねこ'),
          ...Array(3).fill('ハロウィンねねこ'),
          '見習いスニャイパー',
          'ボンボンネコ',
          'おかめはちもくネコ',
          'メタルネコ',
          'にゃんこ城Mini',
          ...Array(3).fill('ねねこ'),
          '金ネコ',
          ...DEFAULT_SUPER2,
        ],
        ['建築兵団スフィンクス', 'ゾンビ娘ヴェルヴェーヌ', '風隼さくら', '海王神ポセイドン', '天誅ハヤブサ', 'テコルガ', 'かぐやひめ', 'ネコシュバリエ'],
        [],
      ],
      keys: ['メタル'],
      has: '風隼さくら',
    },
    wavebusters: {
      name: '波動バスターズ',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        [...DEFAULT_RARE].reverse(),
        [
          '見習いスニャイパー',
          'ボンボンネコ',
          'おかめはちもくネコ',
          'メタルネコ',
          'にゃんこ城mini',
          'ねねこ',
          '金ネコ',
          'ネコぼさつ',
          'ネコ番長',
          'ネコザイル',
          'ねこタツ',
          'オタネコ',
          'ネコスイマー',
          'ネコリンゴ',
          'ネコバスたぶ',
          'ねこ寿司',
          '窓辺の乙女ネコ',
          'ネコバーベル',
          'ネコスケート',
          'ネコトースター',
          'ネコサーファー',
          'ネコジャンパー',
          'ネコフェンシング',
          '泉のネコ女神',
        ],
        ['地獄警官エマ', 'ラスヴォース', 'ノビルガ', '守護神アヌビス', 'トゲルガ', 'アキラ', '前田慶次', 'ネコマシン'],
        [],
      ],
      keys: ['波動'],
      has: '地獄警官エマ',
    },
    choSeimeitai: {
      name: '超生命体バスターズ',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        ['金ネコ', 'ねねこ', 'にゃんこ城mini', 'メタルネコ', 'おかめはちもくネコ', 'ボンボンネコ', '見習いスニャイパー', ...DEFAULT_SUPER2],
        ['光の女神シリウス', 'ネコ天狗', '服部半蔵', '狩猟娘テルン', '海龍ダライアサン', '周遊芸団カルーセルズ', '女神ベガ', '氷の精霊フリズ'],
        [],
      ],
      keys: ['超生命体'],
      has: '光の女神シリウス',
    },
    '---nekosai---': {
      name: '―――ネコ祭他―――',
      disabled: true,
    },
    choNeko: {
      name: '超ネコ祭',
      rate: [6469, 9069, 9969, 9999],
      characters: [
        DEFAULT_RARE,
        DEFAULT_SUPER2,
        [
          '曲射砲台ランチャーズ',
          'マモルガ',
          '幼天女ルーナ',
          '特命機動アクセル',
          '花咲かじいさん',
          'ネコダイナザウルス',
          '砲龍ガンドロス',
          '明智光秀',
          '鉄籠のペガサ',
          '光翼神イシス',
          '鉄の精霊カッチン',
          '建築兵団スフィンクス',
          'カオルガ',
          'サンダージャック',
          'いっすん法師',
          '運命の子フォノ',
          '周遊芸団カルーセルズ',
          'ネコ天狗',
          '海龍ダライアサン',
          '氷の精霊フリズ',
          '服部半蔵',
          '狩猟娘テルン',
          '堕天神ルシファー',
          '踊り子イズ',
          '白騎士キュクロプス',
          '舌切りすずめ',
          '超竜戦機デス・トロイ',
          '闇の精霊ヤミィ',
          'オコルガ',
          '邪龍ヘヴィジャーク',
          '妖賢女リリン',
          '天草四郎',
          '召喚少年サトル',
          '空中商会コロンブス',
          '幼獣ガル',
          '石の精霊ゴロー',
          'オイルガ',
          '冥界神ハデス',
          'マッドシューター・サキ',
          '厄災の子キャスリィ',
          'きんたろう',
          'ラスヴォース',
          '角龍グラディオス',
          '英雄令嬢メルシュ',
          '成田甲斐',
          '時空神クロノス',
          'ノビルガ',
          '亡者探偵ヴィグラー',
          'ネコクエスト',
          '温泉天国テルマエ',
          '雷の精霊ボルト',
          '古龍ガングリオン',
          '幼傑ダルターニャ',
          '風の精霊エアル',
          '水の精霊ミズリィ',
          '火の精霊メララ',
          '観測兵器ガリレオ',
          '双掌星のシシル＆コマリ',
          '今川義元',
          'さるかに合戦',
          '巫女姫ミタマ',
          '海王神ポセイドン',
          '飛空襲撃ボンバーズ',
          '古代軍船ガレーズ',
          '帝国陸軍カタパルズ',
          '繁栄神ガネーシャ',
          '太陽神アマテラス',
          '幼獣ガオ',
          'ネコルガ',
          'ネコアイス',
          'ネコマシン',
          '鬼にゃんま',
          'ネコシュバリエ',
          'ねこベビー',
          '真田幸村',
          '前田慶次',
          '織田信長',
          '風神のウィンディ',
          '雷神のサンディア',
          '地龍ソドム',
          '聖龍メギドラ',
          '竜騎士バルス',
          '神龍かむくら',
          '竜戦機ライデン',
          '猿帝のクウ',
          '召し豚のカイ',
          '宝杖のカッパーマイン',
          '伊達政宗',
          '武田信玄',
          'うらしまタロウ',
          'ツルの恩返し',
          'ももたろう',
          'かさじぞう',
          'かぐやひめ',
          'ねこナース',
          '上杉謙信',
          '冥界のカリファ',
          'アシルガ',
          'クビルガ',
          'テコルガ',
          'バララガ',
          '覇龍ディオラムス',
          'アキラ',
          '西園寺メカ子',
          'キャットマンダディ',
          'カチカチヤマンズ',
          'ホワイトラビット',
          '呪術師デスピエロ',
          '天誅ハヤブサ',
          'トゲルガ',
          '天空神ゼウス',
          '守護神アヌビス',
          '美女神アフロディーテ',
        ],
        ['暁のイザナギ'],
      ],
      keys: ['幼天女ルーナ'],
      has: '幼天女ルーナ',
    },
    gokuNeko: {
      name: '極ネコ祭',
      rate: [6469, 9069, 9969, 9999],
      characters: [
        DEFAULT_RARE,
        DEFAULT_SUPER2,
        [
          '曲射砲台ランチャーズ',
          '冥護の天女ルナーシャ',
          'マモルガ',
          '特命機動アクセル',
          '花咲かじいさん',
          'ネコダイナザウルス',
          '砲龍ガンドロス',
          '明智光秀',
          '鉄籠のペガサ',
          '光翼神イシス',
          '鉄の精霊カッチン',
          '建築兵団スフィンクス',
          'カオルガ',
          '非命の王フォノウ',
          'サンダージャック',
          'いっすん法師',
          '周遊芸団カルーセルズ',
          'ネコ天狗',
          '海龍ダライアサン',
          '悲嘆の踊り子イズ',
          '氷の精霊フリズ',
          '服部半蔵',
          '狩猟娘テルン',
          '堕天神ルシファー',
          '白騎士キュクロプス',
          '舌切りすずめ',
          '超竜戦機デス・トロイ',
          '闇の精霊ヤミィ',
          'オコルガ',
          '邪龍ヘヴィジャーク',
          '妖賢女リリン',
          '天草四郎',
          '召喚少年サトル',
          '黒獣ガルディアン',
          '空中商会コロンブス',
          '石の精霊ゴロー',
          'オイルガ',
          '禍根の魔女キャスリィ',
          '冥界神ハデス',
          'マッドシューター・サキ',
          'きんたろう',
          'ラスヴォース',
          '角龍グラディオス',
          '英雄令嬢メルシュ',
          '成田甲斐',
          '影傑ダークダルターニャ',
          '時空神クロノス',
          'ノビルガ',
          '亡者探偵ヴィグラー',
          'ネコクエスト',
          '温泉天国テルマエ',
          '雷の精霊ボルト',
          '古龍ガングリオン',
          '黒無垢のミタマ',
          '風の精霊エアル',
          '水の精霊ミズリィ',
          '火の精霊メララ',
          '観測兵器ガリレオ',
          '双掌星のシシル＆コマリ',
          '今川義元',
          '黒獣ガオウ',
          'さるかに合戦',
          '海王神ポセイドン',
          '飛空襲撃ボンバーズ',
          '古代軍船ガレーズ',
          '帝国陸軍カタパルズ',
          '繁栄神ガネーシャ',
          '太陽神アマテラス',
          'ネコルガ',
          'ネコアイス',
          'ネコマシン',
          '鬼にゃんま',
          'ネコシュバリエ',
          'ねこベビー',
          '真田幸村',
          '前田慶次',
          '織田信長',
          '風神のウィンディ',
          '雷神のサンディア',
          '地龍ソドム',
          '聖龍メギドラ',
          '竜騎士バルス',
          '神龍かむくら',
          '竜戦機ライデン',
          '猿帝のクウ',
          '召し豚のカイ',
          '宝杖のカッパーマイン',
          '伊達政宗',
          '武田信玄',
          'うらしまタロウ',
          'ツルの恩返し',
          'ももたろう',
          'かさじぞう',
          'かぐやひめ',
          'ねこナース',
          '上杉謙信',
          '冥界のカリファ',
          'アシルガ',
          'クビルガ',
          'テコルガ',
          'バララガ',
          '覇龍ディオラムス',
          'アキラ',
          '西園寺メカ子',
          'キャットマンダディ',
          'カチカチヤマンズ',
          'ホワイトラビット',
          '呪術師デスピエロ',
          '天誅ハヤブサ',
          'トゲルガ',
          '天空神ゼウス',
          '守護神アヌビス',
          '美女神アフロディーテ',
        ],
        ['宵のイザナミ'],
      ],
      keys: ['冥護の天女ルナーシャ'],
      has: '冥護の天女ルナーシャ',
    },
    king: {
      name: '国王祭',
      rate: [6769, 9269, 9969, 9999],
      characters: [
        DEFAULT_RARE,
        ['スモウ・ザ・ミイラ', 'バレンタインねねこ', '救命にゃんこ', '日焼けネコ', 'イースターねねこ', '大掃除ねねこ', '夏色ねねこ', 'ハロウィンねねこ', ...DEFAULT_SUPER2],
        [
          'マジシャンキャットマン',
          '冬将軍・成田甲斐',
          'パンプキンソドム',
          'サマーフェスサンディア',
          'ネコケーキマシン挙式',
          'スプリングカリファ',
          'ネコアイスホワイトスター',
          '波打ち際の冒険家カンナ',
          'バララガの誓い',
          '決闘少年ラビットサトル',
          '白執事探偵ヴィグラー',
          'トナカイ娘テルン',
          '伯爵・真田幸村',
          'ナイトビーチリリン',
          '祝福神クロノス',
          '恋番長・鬼にゃんま',
          '白い恋人メカ子',
          '渚のかぐやひめ',
          '春龍かむくら',
          '初恋令嬢メルシュ',
          '恋女神ショコラディーテ',
          '前田サンタ慶次',
          '竜騎士スカルバルス',
          'ネコルガの夏',
          'アクアシューター・サキ',
          '冬天使のシシル＆コマリ',
          '潮風のセーラーカッパー',
          '灼熱のビーチクウ',
          '常夏の果実カイ',
          '道化師エッグダック',
          '上杉謙信・春',
          'ネコナースキャンドル',
          'ネコアイスゴースト',
          '真夏のホワイトラビット',
          'トロピカルカリファ',
          '聖夜のシスターカッパー',
          'サンタのメリークウ',
          '雪だるまのスノーカイ',
          'デビルサンディア',
          'ウィンディスイート',
        ],
        ['ネコ王子'],
      ],
      keys: ['国王祭'],
      has: 'ウィンディスイート',
    },
    queen: {
      name: '女王祭',
      rate: [6939, 9439, 9939, 9999],
      characters: [
        DEFAULT_RARE,
        DEFAULT_SUPER2,
        [
          'ねこナース',
          '成田甲斐',
          '妖賢女リリン',
          '舌切りすずめ',
          'ホワイトラビット',
          '太陽神アマテラス',
          '女神ベガ',
          'ネコアイスゴースト',
          'トナカイ娘テルン',
          '波打ち際の冒険家カンナ',
          '上杉謙信・春',
          '白い恋人メカ子',
          '祝福神クロノス',
          'ネコ王女',
        ],
        ['宮本武蔵', '聖会長ジャンヌダルク', '天城龍バベル', 'うしわか丸', 'ワンダー・モモコ', 'レジェルガ', '終末兵器ムー', '幻の精霊ルミナ', '超越科学者ヘヴン博士', '創造神ガイア', '京坂七穂'],
      ],
      keys: ['ネコ王女'],
      has: 'ネコ王女',
    },
    gokusenbatsu: {
      name: '極選抜祭',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        ['ネコ七福神', ...DEFAULT_SUPER2],
        [
          'ネコルガ',
          'ネコマシン',
          '成田甲斐',
          '冥界のカリファ',
          '竜戦機ライデン',
          '舌切りすずめ',
          '特命機動アクセル',
          '繁栄神ガネーシャ',
          '周遊芸団カルーセルズ',
          '狐娘ヒメユリ',
          '火の精霊メララ',
          '黒ちびネコヴァルキリー',
          '影傑ダークダルターニャ',
        ],
        [],
      ],
      keys: ['周年'],
      has: '黒ちびネコヴァルキリー',
    },
    chosenbatsu: {
      name: '超選抜祭',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        ['ネコ七福神', ...DEFAULT_SUPER2],
        [
          'アシルガ',
          'ねこナース',
          '武田信玄',
          '雷神のサンディア',
          '古龍ガングリオン',
          'いっすん法師',
          'サンダージャック',
          '堕天神ルシファー',
          '建築兵団スフィンクス',
          'ミイラ娘レイカ',
          '石の精霊ゴロー',
          'ちびネコヴァルキリー',
          '謎の傭兵トリクシー',
        ],
        [],
      ],
      keys: ['周年'],
      has: '謎の傭兵トリクシー',
    },
    platinum: {
      name: 'プラチナガチャ',
      rate: [0, 0, 9999, 9999],
      characters: [
        [],
        [],
        [
          '曲射砲台ランチャーズ',
          '冥護の天女ルナーシャ',
          'マモルガ',
          '幼天女ルーナ',
          '特命機動アクセル',
          '花咲かじいさん',
          'ネコダイナザウルス',
          '砲龍ガンドロス',
          '明智光秀',
          '鉄籠のペガサ',
          '光翼神イシス',
          '鉄の精霊カッチン',
          '建築兵団スフィンクス',
          'カオルガ',
          '非命の王フォノウ',
          'サンダージャック',
          'いっすん法師',
          '運命の子フォノ',
          '光の女神シリウス',
          '周遊芸団カルーセルズ',
          'ネコ天狗',
          '海龍ダライアサン',
          '悲嘆の踊り子イズ',
          '氷の精霊フリズ',
          '服部半蔵',
          '狩猟娘テルン',
          '堕天神ルシファー',
          '踊り子イズ',
          '白騎士キュクロプス',
          '舌切りすずめ',
          '超竜戦機デス・トロイ',
          '闇の精霊ヤミィ',
          'オコルガ',
          '邪龍ヘヴィジャーク',
          '妖賢女リリン',
          '天草四郎',
          '召喚少年サトル',
          'ネコ王女',
          '黒獣ガルディアン',
          '空中商会コロンブス',
          '幼獣ガル',
          '石の精霊ゴロー',
          '地獄警官エマ',
          'オイルガ',
          '禍根の魔女キャスリィ',
          '冥界神ハデス',
          'マッドシューター・サキ',
          '厄災の子キャスリィ',
          'きんたろう',
          'ラスヴォース',
          '角龍グラディオス',
          '英雄令嬢メルシュ',
          '成田甲斐',
          '影傑ダークダルターニャ',
          '時空神クロノス',
          'ノビルガ',
          '亡者探偵ヴィグラー',
          'ネコクエスト',
          '温泉天国テルマエ',
          '雷の精霊ボルト',
          '風隼さくら',
          '古龍ガングリオン',
          '幼傑ダルターニャ',
          '黒無垢のミタマ',
          '風の精霊エアル',
          '水の精霊ミズリィ',
          '火の精霊メララ',
          '観測兵器ガリレオ',
          '双掌星のシシル＆コマリ',
          '今川義元',
          '黒獣ガオウ',
          'さるかに合戦',
          '巫女姫ミタマ',
          '海王神ポセイドン',
          '飛空襲撃ボンバーズ',
          '古代軍船ガレーズ',
          '帝国陸軍カタパルズ',
          '閃雷機兵レイ',
          '猫飯拳パイパイ',
          '幼獣ガオ',
          'ネコルガ',
          'アシルガ',
          'クビルガ',
          'テコルガ',
          'バララガ',
          'トゲルガ',
          'ネコアイス',
          'ネコマシン',
          '鬼にゃんま',
          'ネコシュバリエ',
          'ねこベビー',
          'ねこナース',
          '真田幸村',
          '前田慶次',
          '織田信長',
          '伊達政宗',
          '武田信玄',
          '上杉謙信',
          '風神のウィンディ',
          '雷神のサンディア',
          '猿帝のクウ',
          '召し豚のカイ',
          '宝杖のカッパーマイン',
          '冥界のカリファ',
          '地龍ソドム',
          '聖龍メギドラ',
          '竜騎士バルス',
          '神龍かむくら',
          '竜戦機ライデン',
          '覇龍ディオラムス',
          'うらしまタロウ',
          'ツルの恩返し',
          'ももたろう',
          'かさじぞう',
          'かぐやひめ',
          'カチカチヤマンズ',
          'アキラ',
          '西園寺メカ子',
          'キャットマンダディ',
          'ホワイトラビット',
          '呪術師デスピエロ',
          '天誅ハヤブサ',
          '天空神ゼウス',
          '守護神アヌビス',
          '美女神アフロディーテ',
          '太陽神アマテラス',
          '繁栄神ガネーシャ',
        ],
        [],
      ],
      keys: ['プラチナ'],
      has: '冥護の天女ルナーシャ',
    },
    legend: {
      name: 'レジェンドガチャ',
      rate: [0, 0, 9499, 9999],
      characters: [
        [],
        [],
        [
          '曲射砲台ランチャーズ',
          '冥護の天女ルナーシャ',
          'マモルガ',
          '幼天女ルーナ',
          '特命機動アクセル',
          '花咲かじいさん',
          'ネコダイナザウルス',
          '砲龍ガンドロス',
          '明智光秀',
          '鉄籠のペガサ',
          '光翼神イシス',
          '鉄の精霊カッチン',
          '建築兵団スフィンクス',
          'カオルガ',
          '非命の王フォノウ',
          'サンダージャック',
          'いっすん法師',
          '運命の子フォノ',
          '光の女神シリウス',
          '周遊芸団カルーセルズ',
          'ネコ天狗',
          '海龍ダライアサン',
          '悲嘆の踊り子イズ',
          '氷の精霊フリズ',
          '服部半蔵',
          '狩猟娘テルン',
          '堕天神ルシファー',
          '踊り子イズ',
          '白騎士キュクロプス',
          '舌切りすずめ',
          '超竜戦機デス・トロイ',
          '闇の精霊ヤミィ',
          'オコルガ',
          '邪龍ヘヴィジャーク',
          '妖賢女リリン',
          '天草四郎',
          '召喚少年サトル',
          'ネコ王女',
          '黒獣ガルディアン',
          '空中商会コロンブス',
          '幼獣ガル',
          '石の精霊ゴロー',
          '地獄警官エマ',
          'オイルガ',
          '禍根の魔女キャスリィ',
          '冥界神ハデス',
          'マッドシューター・サキ',
          '厄災の子キャスリィ',
          'きんたろう',
          'ラスヴォース',
          '角龍グラディオス',
          '英雄令嬢メルシュ',
          '成田甲斐',
          '影傑ダークダルターニャ',
          '時空神クロノス',
          'ノビルガ',
          '亡者探偵ヴィグラー',
          'ネコクエスト',
          '温泉天国テルマエ',
          '雷の精霊ボルト',
          '風隼さくら',
          '古龍ガングリオン',
          '幼傑ダルターニャ',
          '黒無垢のミタマ',
          '風の精霊エアル',
          '水の精霊ミズリィ',
          '火の精霊メララ',
          '観測兵器ガリレオ',
          '双掌星のシシル＆コマリ',
          '今川義元',
          '黒獣ガオウ',
          'さるかに合戦',
          '巫女姫ミタマ',
          '海王神ポセイドン',
          '飛空襲撃ボンバーズ',
          '古代軍船ガレーズ',
          '帝国陸軍カタパルズ',
          '閃雷機兵レイ',
          '猫飯拳パイパイ',
          '幼獣ガオ',
          'ネコルガ',
          'アシルガ',
          'クビルガ',
          'テコルガ',
          'バララガ',
          'トゲルガ',
          'ネコアイス',
          'ネコマシン',
          '鬼にゃんま',
          'ネコシュバリエ',
          'ねこベビー',
          'ねこナース',
          '真田幸村',
          '前田慶次',
          '織田信長',
          '伊達政宗',
          '武田信玄',
          '上杉謙信',
          '風神のウィンディ',
          '雷神のサンディア',
          '猿帝のクウ',
          '召し豚のカイ',
          '宝杖のカッパーマイン',
          '冥界のカリファ',
          '地龍ソドム',
          '聖龍メギドラ',
          '竜騎士バルス',
          '神龍かむくら',
          '竜戦機ライデン',
          '覇龍ディオラムス',
          'うらしまタロウ',
          'ツルの恩返し',
          'ももたろう',
          'かさじぞう',
          'かぐやひめ',
          'カチカチヤマンズ',
          'アキラ',
          '西園寺メカ子',
          'キャットマンダディ',
          'ホワイトラビット',
          '呪術師デスピエロ',
          '天誅ハヤブサ',
          '天空神ゼウス',
          '守護神アヌビス',
          '美女神アフロディーテ',
          '太陽神アマテラス',
          '繁栄神ガネーシャ',
        ],
        [
          '宵のイザナミ',
          '暁のイザナギ',
          'ネコ王子',
          '創造神ガイア',
          '超越科学者ヘヴン博士',
          '幻の精霊ルミナ',
          '終末兵器ムー',
          'レジェルガ',
          'ワンダー・モモコ',
          'うしわか丸',
          '天城龍バベル',
          '聖会長ジャンヌダルク',
          '宮本武蔵',
        ],
      ],
      keys: ['レジェンド'],
      has: '冥護の天女ルナーシャ',
    },
    '---season---': {
      name: '―――季節―――',
      disabled: true,
    },
    valentine: {
      name: 'バレンタイン',
      rate: [6999, 9499, 9999, 9999],
      twiceRate: [6499, 8999, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        [...Array(4).fill('バレンタインねねこ'), '洗脳されしバトルネコ', '洗脳されしネコノトリ', '洗脳されし巨神ネコ', ...DEFAULT_SUPER2],
        ['上杉謙信', 'ホワイトラビット', '狼娘ディル', '妖賢女リリン', '恋女神ショコラディーテ', '初恋令嬢メルシュ', '白い恋人メカ子'],
        [],
      ],
      keys: ['バレンタイン'],
      has: '白い恋人メカ子',
    },
    white: {
      name: 'ホワイトデー',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        ['洗脳されしキモネコ', '洗脳されしネコトカゲ', '洗脳されし巨神ネコ', ...DEFAULT_SUPER2],
        ['マジシャンキャットマン', 'ネコアイスホワイトスター', '白執事探偵ヴィグラー', '恋番長・鬼にゃんま', '海王神ポセイドン', '服部半蔵', 'いっすん法師'],
        [],
      ],
      keys: ['ホワイトデー'],
      has: 'マジシャンキャットマン',
    },
    spring: {
      name: 'イースター',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        [...Array(4).fill('イースターねねこ'), '洗脳されしネコフィッシュ', '洗脳されしネコノトリ', '洗脳されしバトルネコ', ...DEFAULT_SUPER2],
        ['スプリングカリファ', '決闘少年ラビットサトル', '上杉謙信・春', '道化師エッグダック', '春龍かむくら'],
        [],
      ],
      keys: ['春'],
      has: '春龍かむくら',
    },
    juneBride: {
      name: 'ジューンブライド',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        ['洗脳されしネコ', '洗脳されしタンクネコ', '洗脳されしウシネコ', ...DEFAULT_SUPER2],
        ['ネコケーキマシン挙式', 'バララガの誓い', '祝福神クロノス', '海龍ダライアサン', 'ゾンビ娘ヴェルヴェーヌ', 'ツルの恩返し', '前田慶次'],
        [],
      ],
      keys: ['ジューンブライド'],
      has: 'ネコケーキマシン挙式',
    },
    summer: {
      name: 'サマーガールズS',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        [
          '洗脳されしバトルネコ',
          '洗脳されしネコノトリ',
          '洗脳されしネコフィッシュ',
          ...Array(3).fill('夏色ねねこ'),
          ...Array(3).fill('日焼けネコ'),
          ...Array(3).fill('救命にゃんこ'),
          ...DEFAULT_SUPER2,
        ],
        ['常夏の果実カイ', '灼熱のビーチクウ', '潮風のセーラーカッパー', 'ネコルガの夏', '波打ち際の冒険家カンナ'],
        [],
      ],
      keys: ['夏'],
      has: '常夏の果実カイ',
    },
    summer2: {
      name: 'サマーガールズB',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        ['洗脳されしキモネコ', '洗脳されしネコトカゲ', '洗脳されし巨神ネコ', ...Array(3).fill('夏色ねねこ'), ...Array(3).fill('日焼けネコ'), ...Array(3).fill('救命にゃんこ'), ...DEFAULT_SUPER2],
        ['サマーフェスサンディア', 'トロピカルカリファ', '真夏のホワイトラビット', 'アクアシューター・サキ', '渚のかぐやひめ', 'ナイトビーチリリン'],
        [],
      ],
      keys: ['夏'],
      has: 'ナイトビーチリリン',
    },
    sports1: {
      name: '運動会【赤】',
      rate: [6999, 9499, 9999, 9999],
      characters: [DEFAULT_RARE, DEFAULT_SUPER2, ['地龍ソドム', '猿帝のクウ', 'ももたろう', 'テコルガ', 'アキラ', '太陽神アマテラス', '今川義元', '火の精霊メララ', '召喚少年サトル'], []],
      keys: ['運動会'],
      has: '召喚少年サトル',
    },
    sports2: {
      name: '運動会【白】',
      rate: [6999, 9499, 9999, 9999],
      characters: [DEFAULT_RARE, DEFAULT_SUPER2, ['覇龍ディオラムス', '妖賢女リリン', 'ホワイトラビット', '海王神ポセイドン', '雷の精霊ボルト', 'かさじぞう', '天草四郎', 'オコルガ', 'ネコ天狗'], []],
      keys: ['運動会'],
      has: 'ネコ天狗',
    },
    halloween: {
      name: 'ハロウィン',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        [...Array(3).fill('スモウ・ザ・ミイラ'), ...Array(3).fill('ハロウィンねねこ'), '洗脳されしネコ', '洗脳されしタンクネコ', '洗脳されしウシネコ', ...DEFAULT_SUPER2],
        ['パンプキンソドム', '伯爵・真田幸村', 'ウィンディスイート', 'デビルサンディア', 'ネコアイスゴースト', '竜騎士スカルバルス'],
        [],
      ],
      keys: ['ハロウィン'],
      has: 'パンプキンソドム',
    },
    xmas: {
      name: 'クリスマス',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        ['洗脳されしキモネコ', '洗脳されしネコトカゲ', '洗脳されし巨神ネコ', ...DEFAULT_SUPER2],
        ['冬将軍・成田甲斐', '雪だるまのスノーカイ', 'サンタのメリークウ', '聖夜のシスターカッパー', 'ネコナースキャンドル', '冬天使のシシル＆コマリ', '前田サンタ慶次', 'トナカイ娘テルン'],
        [],
      ],
      keys: ['クリスマス'],
      has: '冬将軍・成田甲斐',
    },
    '---collab---': {
      name: '―――コラボ―――',
      disabled: true,
    },
    manbo: {
      name: 'マンボ王',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        DEFAULT_RARE,
        [...Array(6).fill('厨房マンボウ'), 'おかめはちもくネコ', 'ボンボンネコ', '見習いスニャイパー', '金ネコ', 'ねねこ', 'にゃんこ城Mini', 'メタルネコ', ...DEFAULT_SUPER2],
        ['マンボ王'],
        [],
      ],
      keys: [''],
      has: 'マンボ王',
    },
    eva: {
      name: 'エヴァ',
      rate: [6969, 9469, 9969, 9999],
      characters: [
        [...Array(3).fill('ネコレイ'), ...Array(3).fill('ネコアスカ'), ...Array(3).fill('ネコマリ'), ...Array(3).fill('ネコカヲル'), ...DEFAULT_RARE],
        ['ちびレイ', 'ちびアスカ', 'ちびミサト', ...DEFAULT_SUPER2],
        ['エヴァ量産機', 'エヴァ零号機', 'エヴァ初号機', 'ネコシンジ', '白夜姫のレイ', '第６の使徒', '第１０の使徒'],
        ['月影の少年カヲル'],
      ],
      keys: [''],
      has: 'エヴァ量産機',
    },
    eva2: {
      name: 'エヴァ2',
      rate: [6969, 9469, 9969, 9999],
      characters: [
        [...Array(3).fill('ネコレイ'), ...Array(3).fill('ネコアスカ'), ...Array(3).fill('ネコマリ'), ...Array(3).fill('ネコカヲル'), ...DEFAULT_RARE],
        ['ちびマリ', 'ちびリツコ', 'ちびアヤナミレイ(仮称)', ...DEFAULT_SUPER2],
        ['エヴァ２号機', 'ゼロムーンオペレーターズ', 'エヴァ８号機', '空中艦艇ネコヴンダー', '第４の使徒', '第９の使徒', '隻眼の少女アスカ', 'エヴァ第１３号機'],
        ['月影の少年カヲル'],
      ],
      keys: [''],
      has: 'エヴァ２号機',
    },
    sonic: {
      name: 'ソニック',
      rate: [6999, 9499, 9999, 9999],
      characters: [[...Array(10).fill('ネコシャドウ'), ...DEFAULT_RARE], DEFAULT_SUPER2, ['ソニック', 'テイルス', 'ナックルズ', 'シャドウ'], []],
      keys: [''],
      has: 'ソニック',
    },
    baki: {
      name: 'バキ',
      rate: [6999, 9499, 9999, 9999],
      characters: [DEFAULT_RARE, [...Array(6).fill('ネコオーガ'), ...DEFAULT_SUPER2], ['範馬刃牙', '烈海王', '花山薫', '愚地克巳', 'ジャック・ハンマー'], []],
      keys: [''],
      has: '範馬刃牙',
    },
    madoka: {
      name: 'まどマギ',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        [...Array(4).fill('ネコ杏子'), ...Array(4).fill('ネコマミ'), ...Array(4).fill('ネコさやか'), ...Array(4).fill('ネコほむら'), ...Array(4).fill('ネコまどか'), ...DEFAULT_RARE],
        [...Array(6).fill('キュゥべえ'), ...DEFAULT_SUPER2],
        ['ネコまどか＆ほむら', 'ベベ', '佐倉杏子', '巴マミ', '美樹さやか', '暁美ほむら', '鹿目まどか'],
        [],
      ],
      keys: [''],
      has: '鹿目まどか',
    },
    mercstoria: {
      name: 'メルスト',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        ['セレス', 'ノノ', 'オルガ', 'ノルン', 'よいち', 'セラム', 'フウ'],
        ['オルトス', 'シトルイユ', 'アロイス', 'アウラ', 'レイ'],
        ['たいてんき', 'アイウォルツ', 'とどめき', 'ミシェリア', 'ミスティカ', 'ユーヴェンス', 'コーネリア', 'ハルシュト', 'ワイバーン'],
        [],
      ],
      keys: [''],
      has: 'たいてんき',
    },
    bikkuri: {
      name: 'ビックリマン',
      rate: [6969, 9469, 9969, 9999],
      characters: [
        DEFAULT_RARE,
        [...Array(3).fill('騎神アリババ'), ...Array(3).fill('ネロ魔身'), ...DEFAULT_SUPER2],
        ['天空神スーパーゼウス', 'シャーマンカーン', 'ヘラクライスト', 'サタンマリア', 'スーパーデビル', '聖フェニックス', 'スーパーゼウス'],
        ['ブラックゼウス'],
      ],
      keys: [''],
      has: '天空神スーパーゼウス',
    },
    shometsu: {
      name: '消滅都市',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        [
          'ネコ武闘家',
          'ネコマタドール',
          ...Array(10).fill('そうまにゃん'),
          'ネコ探査機',
          'ネコボクサー',
          'ネコバサミ',
          'ねこ陰陽師',
          'サイキックネコ',
          'ねこ人魚',
          'ねこロッカー',
          'ブリキネコ',
          'たけうまねこ',
          'ねこガンマン',
          'ネコ魔剣士',
          'ネコアーチャー',
          'ネコ魔女',
          'ネコシャーマン',
          'ねこ占い師',
          'ねこ僧侶',
          'ねこ泥棒',
          'ねこ海賊',
          'ねこファイター',
          'ねこジュラ',
          'ネコエステ',
          'ネコ車輪',
          'ネコホッピング',
        ],
        [
          '泉のネコ女神',
          ...Array(6).fill('オタネコギーク'),
          'ネコフェンシング',
          'ネコジャンパー',
          'ネコサーファー',
          'ネコトースター',
          'ネコスケート',
          'ネコバーベル',
          '窓辺の乙女ネコ',
          'ねこ寿司',
          'ネコバスたぶ',
          'ネコリンゴ',
          'ネコスイマー',
          'オタネコ',
          'ねこタツ',
          'ネコザイル',
          'ネコ番長',
          'ネコぼさつ',
        ],
        ['幸せを願った少年ソウマ', '失われし世界のユキ', '狂乱のユキ', '謎の少女ユキ'],
        [],
      ],
      keys: [''],
      has: '幸せを願った少年ソウマ',
    },
    kenshin: {
      name: 'るろうに剣心',
      rate: [6999, 9499, 9999, 9999],
      characters: [DEFAULT_RARE, [...Array(3).fill('ちび薫'), ...Array(3).fill('ちび弥彦'), ...DEFAULT_SUPER2], ['緋村剣心', '相楽左之助', '四乃森蒼紫', '斎藤一'], []],
      keys: [''],
      has: '斎藤一',
    },
    metalslug: {
      name: 'メタルスラッグ',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        [...Array(3).fill('マルコ'), ...Array(3).fill('ターマ'), ...Array(3).fill('エリ'), ...Array(3).fill('フィオ'), ...Array(3).fill('マーズピープル'), ...DEFAULT_RARE],
        [...Array(3).fill('SV-001'), ...Array(3).fill('アレン・オニール'), ...DEFAULT_SUPER2],
        ['ソル・デ・ロカ', 'ヒュージハーミット', 'ジュピターキング', 'モーデン元帥', 'ハイ・ドゥ'],
        [],
      ],
      keys: [''],
      has: 'モーデン元帥',
    },
    miku: {
      name: '初音ミク',
      rate: [6999, 9499, 9999, 9999],
      characters: [
        [...Array(3).fill('ネコレン'), ...Array(3).fill('ネコリン'), ...Array(3).fill('ネコルカ'), ...DEFAULT_RARE],
        [...Array(3).fill('KAITO＆ネコ'), ...Array(3).fill('MEIKO＆ネコ'), ...DEFAULT_SUPER2],
        ['初音ミク 16th', '雪ミク 2021', '初音ミク マジカルミライ2020東京', '初音ミク マジカルミライ2020大阪', '巡音ルカ', '初音ミク', '桜ミク', '鏡音リン＆レン'],
        [],
      ],
      keys: [''],
      has: '初音ミク',
    },
    kerihime: {
      name: 'ケリ姫',
      rate: [6999, 9499, 9999, 9999],
      characters: [['剣士', 'ウシ姫', 'チビガウ'], ['ひな', 'ユーリンチー', '執行者'], ['エルメ', 'カレット', 'プリンセスケリ姫号', '狂乱のケリ姫', 'KHM48'], []],
      keys: [''],
      has: 'エルメ',
    },
  };
  const fifteenGuaranteedKeys = ['redbusters', 'metalbusters', 'airbusters', 'wavebusters', 'choSeimeitai'];
  const specialCharacters = [
    '黒獣ガオウ',
    '黒無垢のミタマ',
    '幼獣ガオ',
    '巫女姫ミタマ',
    '厄災の子キャスリィ',
    '影傑ダークダルターニャ',
    '黒獣ガルディアン',
    '幼傑ダルターニャ',
    '悲嘆の踊り子イズ',
    '運命の子フォノ',
    '非命の王フォノウ',
    '幼天女ルーナ',
    '冥護の天女ルナーシャ',
    '禍根の魔女キャスリィ',
    '踊り子イズ',
    '幼獣ガル',
    '暁のイザナギ',
    '宵のイザナミ',
    'ネコ王女',
    'ネコ王子',
    '黒ちびネコヴァルキリー',
    'ちびネコヴァルキリー',
    '謎の傭兵トリクシー',
    '光の女神シリウス',
    '地獄警官エマ',
    '閃雷機兵レイ',
    '猫飯拳パイパイ',
    '風隼さくら',
  ];

  // ==================== 高速化・XORShift関数 ====================

  // XORShift32アルゴリズムによる疑似乱数生成
  function xorshift32(x) {
    x = (x ^ (x << 13)) >>> 0;
    x = (x ^ (x >>> 17)) >>> 0;
    x = (x ^ (x << 15)) >>> 0;
    return x;
  }

  // シードを指定ステップ数進める
  function advanceSeed(seed, steps) {
    let currentSeed = seed >>> 0;
    for (let i = 0; i < steps; i++) {
      currentSeed = xorshift32(currentSeed);
    }
    return currentSeed;
  }

  // XORShiftの逆算関数
  function reverseXorshift32(seed, steps) {
    for (let i = 0; i < steps; i++) {
      seed = (seed ^ (seed << 15)) >>> 0;
      seed = (seed ^ (seed << 30)) >>> 0;
      seed = (seed ^ (seed >>> 17)) >>> 0;
      seed = (seed ^ (seed << 13)) >>> 0;
      seed = (seed ^ (seed << 26)) >>> 0;
    }
    return seed >>> 0; // 32bit unsignedに変換
  }

  // ==================== 高速化用のキャッシュとバッチ処理クラス ====================
  class SeedProcessor {
    constructor() {
      this.cache = new Map();
      this.allSeeds = [];
      this.isProcessing = false;
    }

    // XORShift32
    xorshift32(x) {
      x = (x ^ (x << 13)) >>> 0;
      x = (x ^ (x >>> 17)) >>> 0;
      x = (x ^ (x << 15)) >>> 0;
      return x;
    }

    // TypedArrayを使用した高速シード生成
    generateAllSeedsOptimized(currentSeed, count) {
      const cacheKey = `${currentSeed}_${count}`;
      if (this.cache.has(cacheKey)) {
        console.log('キャッシュからシードを取得');
        return this.cache.get(cacheKey);
      }

      const totalSteps = 2 * count + 1;
      console.time('シード生成時間');

      // Uint32Arrayを使用してメモリ効率向上
      const seeds = new Uint32Array(totalSteps);
      let seed = currentSeed;

      // ループ展開高速
      let i = 0;
      const remainderStart = totalSteps - (totalSteps % 4);

      // 4つずつ処理（ループ展開）
      for (; i < remainderStart; i += 4) {
        seed = (seed ^ (seed << 13)) >>> 0;
        seed = (seed ^ (seed >>> 17)) >>> 0;
        seed = (seed ^ (seed << 15)) >>> 0;
        seeds[i] = seed;

        seed = (seed ^ (seed << 13)) >>> 0;
        seed = (seed ^ (seed >>> 17)) >>> 0;
        seed = (seed ^ (seed << 15)) >>> 0;
        seeds[i + 1] = seed;

        seed = (seed ^ (seed << 13)) >>> 0;
        seed = (seed ^ (seed >>> 17)) >>> 0;
        seed = (seed ^ (seed << 15)) >>> 0;
        seeds[i + 2] = seed;

        seed = (seed ^ (seed << 13)) >>> 0;
        seed = (seed ^ (seed >>> 17)) >>> 0;
        seed = (seed ^ (seed << 15)) >>> 0;
        seeds[i + 3] = seed;
      }

      // 残りを処理
      for (; i < totalSteps; i++) {
        seed = this.xorshift32(seed);
        seeds[i] = seed;
      }

      // 通常の配列に変換
      this.allSeeds = Array.from(seeds);

      console.timeEnd('シード生成時間');

      // キャッシュに保存（最大5つまで）
      if (this.cache.size >= 5) {
        const firstKey = this.cache.keys().next().value;
        this.cache.delete(firstKey);
      }
      this.cache.set(cacheKey, this.allSeeds);

      return this.allSeeds;
    }

    // レア該当インデックスの高速取得
    getRareValidIndicesOptimized(threshold) {
      console.time('レア判定時間');

      const validIndices = [];
      const seeds = this.allSeeds;
      const length = seeds.length;

      // 元のロジックを維持（% 10000を使用）
      for (let i = 0; i < length; i++) {
        const last4Digits = seeds[i] % 10000;
        if (last4Digits <= threshold) {
          validIndices.push(i);
        }
      }

      console.timeEnd('レア判定時間');
      console.log(`レア該当: ${validIndices.length}個`);

      return validIndices;
    }

    // Web Workers用の並列シード生成
    async generateSeedsParallel(currentSeed, count) {
      const cacheKey = `${currentSeed}_${count}`;
      if (this.cache.has(cacheKey)) {
        console.log('キャッシュからシードを取得');
        return this.cache.get(cacheKey);
      }

      // Web Workers が利用可能か確認
      if (typeof Worker === 'undefined') {
        return this.generateAllSeedsOptimized(currentSeed, count);
      }

      const totalSteps = 2 * count + 1;
      const workerCount = Math.min(4, Math.max(1, navigator.hardwareConcurrency || 2));
      const chunkSize = Math.ceil(totalSteps / workerCount);

      try {
        const promises = [];

        for (let i = 0; i < workerCount; i++) {
          const startIndex = i * chunkSize;
          const endIndex = Math.min(startIndex + chunkSize, totalSteps);

          if (startIndex >= totalSteps) break;

          // 各チャンクの開始シード計算
          let chunkStartSeed = currentSeed;
          for (let j = 0; j < startIndex; j++) {
            chunkStartSeed = this.xorshift32(chunkStartSeed);
          }

          promises.push(this.createWorkerChunk(chunkStartSeed, endIndex - startIndex, startIndex));
        }

        const results = await Promise.all(promises);

        // 結果マージ
        const finalSeeds = new Array(totalSteps);
        results.forEach(({ seeds, startIndex }) => {
          seeds.forEach((seed, i) => {
            finalSeeds[startIndex + i] = seed;
          });
        });

        this.allSeeds = finalSeeds;

        // キャッシュ保存
        if (this.cache.size >= 5) {
          const firstKey = this.cache.keys().next().value;
          this.cache.delete(firstKey);
        }
        this.cache.set(cacheKey, this.allSeeds);

        return this.allSeeds;
      } catch (error) {
        console.warn('並列処理に失敗、シーケンシャル処理にフォールバック:', error);
        return this.generateAllSeedsOptimized(currentSeed, count);
      }
    }

    // Worker チャンクを作成
    createWorkerChunk(startSeed, count, startIndex) {
      return new Promise((resolve, reject) => {
        const workerCode = `
                    function xorshift32(x) {
                        x = (x ^ (x << 13)) >>> 0;
                        x = (x ^ (x >>> 17)) >>> 0;
                        x = (x ^ (x << 15)) >>> 0;
                        return x;
                    }

                    self.onmessage = function(e) {
                        const { startSeed, count } = e.data;
                        const seeds = new Array(count);
                        let seed = startSeed;

                        for (let i = 0; i < count; i++) {
                            seed = xorshift32(seed);
                            seeds[i] = seed;
                        }

                        self.postMessage({ seeds });
                    };
                `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(blob));

        worker.onmessage = (e) => {
          resolve({ seeds: e.data.seeds, startIndex });
          worker.terminate();
          URL.revokeObjectURL(blob);
        };

        worker.onerror = (error) => {
          reject(error);
          worker.terminate();
          URL.revokeObjectURL(blob);
        };

        worker.postMessage({ startSeed, count });
      });
    }
  }

  class ElementCache {
    constructor() {
      this.cache = new Map();
      this.initialized = false;
    }

    init() {
      if (this.initialized) return;

      // 一度だけ要素を取得してキャッシュ
      this.cache.set('compare_gacha_single', document.getElementById('compare_gacha_single'));
      this.cache.set('compare_gacha2_single', document.getElementById('compare_gacha2_single'));
      this.cache.set('current_gacha_eleven', document.getElementById('current_gacha_eleven'));
      this.cache.set('compare_gacha_eleven', document.getElementById('compare_gacha_eleven'));
      this.cache.set('compare_gacha2_eleven', document.getElementById('compare_gacha2_eleven'));

      this.initialized = true;
    }

    get(id) {
      this.init();
      return this.cache.get(id);
    }
  }
  const elementCache = new ElementCache();
  // ==================== グローバル変数とインスタンス ====================
  const seedProcessor = new SeedProcessor();
  const urlParams = new URLSearchParams(window.location.search);
  let collisionData = new Map();
  let currentGachaKey = getGachaKeyFromSelectedText();
  let compareGachaKey = '';
  let compareGachaKey2 = '';
  const countStr = urlParams.get('count');
  const seedStr = urlParams.get('seed');
  const count = countStr ? parseInt(countStr, 10) : 100;
  const currentSeed = seedStr ? parseInt(seedStr, 10) : 0;
  let isPlanMode = false;
  let ticketCounts = { rare: 0, catfood: 0 };
  let selectedTablePositions = new Set();

  // ==================== ユーティリティ関数 ====================
  // インデックス番号をテーブルナンバーに変換
  function indexToTableNumber(index) {
    const isEven = index % 2 === 0;
    const tableNumber = Math.floor(index / 2) + 1;
    const suffix = isEven ? 'A' : 'B';
    return `${tableNumber}${suffix}`;
  }

  // テーブル番号からインデックスを取得
  function getTableIndexes(tableNumber) {
    const match = tableNumber.match(/^(\d+)([AB])$/);
    if (!match) return null;

    const num = parseInt(match[1]);
    const suffix = match[2];

    if (suffix === 'A') {
      const baseIndex = (num - 1) * 2;
      return [baseIndex, baseIndex + 1];
    } else {
      const baseIndex = (num - 1) * 2 + 1;
      return [baseIndex, baseIndex + 1];
    }
  }

  // テーブル番号の変更：1Aなら1Bに、1Bなら1Aに変更
  function toggleTableSuffix(tablePosition) {
    if (tablePosition.endsWith('A')) {
      return tablePosition.slice(0, -1) + 'B';
    } else if (tablePosition.endsWith('B')) {
      return tablePosition.slice(0, -1) + 'A';
    }
    return tablePosition; // AでもBでもなければそのまま返す
  }

  // 連続するテーブルペアを検索
  function findConsecutiveTablePairs(tableNumbers) {
    const pairs = [];
    const sortedTables = [...tableNumbers].sort((a, b) => {
      const aMatch = a.match(/^(\d+)([AB])$/);
      const bMatch = b.match(/^(\d+)([AB])$/);
      const aNum = parseInt(aMatch[1]);
      const bNum = parseInt(bMatch[1]);
      const aSuffix = aMatch[2];
      const bSuffix = bMatch[2];

      if (aSuffix !== bSuffix) return aSuffix.localeCompare(bSuffix);
      return aNum - bNum;
    });

    for (let i = 0; i < sortedTables.length - 1; i++) {
      const current = sortedTables[i];
      const next = sortedTables[i + 1];

      const currentMatch = current.match(/^(\d+)([AB])$/);
      const nextMatch = next.match(/^(\d+)([AB])$/);

      if (currentMatch && nextMatch) {
        const currentNum = parseInt(currentMatch[1]);
        const nextNum = parseInt(nextMatch[1]);
        const currentSuffix = currentMatch[2];
        const nextSuffix = nextMatch[2];

        if (currentSuffix === nextSuffix && nextNum === currentNum + 1) {
          pairs.push([current, next]);
        }
      }
    }

    return pairs;
  }

  // 初期表示するガチャを計算するロジック：イベント名と超激レアキャラから判断
  function getGachaKeyFromSelectedText() {
    const select = document.getElementById('event_select');
    const selectedText = select.options[select.selectedIndex].text;

    const lastSelect = document.getElementById('last_select');
    const uberTexts = [];

    // Uber: グループのオプションテキストを取得
    if (lastSelect) {
      const options = lastSelect.querySelectorAll('optgroup[label="Uber:"] option');
      for (const option of options) {
        uberTexts.push(option.textContent.trim());
      }
    }

    // 条件に一致する key を探す
    for (const key in GACHA_CONFIG) {
      const config = GACHA_CONFIG[key];
      const keys = config.keys || [];
      const has = config.has;

      const hasKeyMatch = keys.some((k) => selectedText.includes(k));
      const hasHasMatch = has ? uberTexts.some((text) => text.includes(has)) : true;

      if (hasKeyMatch && hasHasMatch) {
        return key;
      }
    }

    return 'galaxy';
  }

  // ==================== スロット詳細取得 ====================
  // スロット詳細取得
  function getSlotDetails(tableNumber, gachaKey, reRollChar = '', configOverride = null, isDupForced = false, comparedCharacter = '', isNotDupForced = false) {
    const indexes = getTableIndexes(tableNumber);
    if (!indexes || indexes[0] >= seedProcessor.allSeeds.length || indexes[1] >= seedProcessor.allSeeds.length) {
      return null;
    }

    const rareSeed = seedProcessor.allSeeds[indexes[0]];
    const charSeed = seedProcessor.allSeeds[indexes[1]];

    // configOverrideが指定されている場合はそれを使用、そうでなければ通常の設定を取得
    const config = configOverride || GACHA_CONFIG[gachaKey];
    const rareValue = rareSeed % 10000;

    // rankを算出
    let rank = 'rare';
    let characters = config.characters[0];

    for (let i = 0; i < config.rate.length; i++) {
      if (rareValue <= config.rate[i]) {
        characters = config.characters[i];
        switch (i) {
          case 0:
            rank = 'rare';
            break;
          case 1:
            rank = 'super';
            break;
          case 2:
            rank = 'uber';
            break;
          case 3:
            rank = 'legend';
            break;
        }
        break;
      }
    }

    const charIndex = charSeed % characters.length;
    const character = characters[charIndex];
    let consecutiveRare = false;
    let nextCharacter = '';
    let nextSeed = null;
    let nextTableNumber = indexToTableNumber(indexes[1] + 1);
    let previousTableNumber = '';
    let isReRollAgain = false;

    // レア被り用のキャラ（rareランクのみ）かつ 強制not重複以外
    if (rank === 'rare' && !isNotDupForced) {
      const prevRareSeed = reverseXorshift32(rareSeed, 2);
      const prevCharSeed = reverseXorshift32(rareSeed, 1);
      const prevRareValue = prevRareSeed % 10000;
      // lastRollキャラ
      const select = document.getElementById('last_select');
      const selectedOption = select.options[select.selectedIndex];
      const isFirstDup = tableNumber === '1A' && selectedOption.textContent.trim() === character;

      if (prevRareValue <= config.rate[0] || isDupForced || comparedCharacter === character || isFirstDup) {
        const prevCharIndex = prevCharSeed % characters.length;
        const prevCharacter = characters[prevCharIndex];

        if (reRollChar === character || isDupForced || (comparedCharacter ? comparedCharacter === character : prevCharacter === character) || isFirstDup) {
          consecutiveRare = true;
          let tries = 0;
          const maxTries = characters.length;
          nextSeed = charSeed;

          let availableCharacters = characters.filter((_, index) => index !== charIndex);
          while (tries < maxTries && availableCharacters.length > 0) {
            tries++;
            nextSeed = advanceSeed(nextSeed, 1);
            const nextCharIndex = nextSeed % availableCharacters.length;
            const candidateCharacter = availableCharacters[nextCharIndex];

            if (candidateCharacter !== character) {
              nextCharacter = candidateCharacter;

              nextTableNumber = indexToTableNumber(indexes[1] + 1 + tries);

              const nextDetails = getSlotDetails(nextTableNumber, gachaKey, '', configOverride);
              if (nextDetails && nextDetails.character === nextCharacter) {
                isReRollAgain = true;
              }
              break;
            }

            availableCharacters = availableCharacters.filter((_, index) => index !== nextCharIndex);
          }
        }
      }
    }

    let bgColor = '';
    let color = '';
    if (rareValue >= 6500 && rareValue <= 6999 && (rank === 'rare' || rank === 'super')) {
      bgColor = 'yellow';
    }
    if (specialCharacters.includes(character)) {
      bgColor = 'aqua';
      color = '#275a90';
    }

    return {
      tableNumber,
      rareSeed,
      charSeed,
      rareValue,
      character,
      rank,
      charIndex,
      gachaKey,
      consecutiveRare,
      nextCharacter,
      nextSeed,
      nextTableNumber,
      isReRollAgain,
      bgColor,
      color,
    };
  }

  // 確定列データ取得関数
  function getGuaranteedSlotDetails(tableNumber, gachaKey, configOverride = null, isDupForced = false) {
    let i = 1;
    let calculateTableNumber = tableNumber;
    const guaranteedCount = fifteenGuaranteedKeys.includes(gachaKey) ? 15 : 11;

    let prevCharacter = '';
    while (i < guaranteedCount) {
      const config = configOverride || GACHA_CONFIG[gachaKey];
      const details = getSlotDetails(calculateTableNumber, gachaKey, '', config, i === 1 ? isDupForced : false, prevCharacter);

      if (!details) break;
      prevCharacter = details.rank === 'rare' ? (details.consecutiveRare ? details.nextCharacter : details.character) : '';
      calculateTableNumber = details.nextTableNumber;
      i++;
    }

    // レア被り枠確定用
    const firstDetails = getSlotDetails(tableNumber, gachaKey, '', configOverride);
    const firstIndexes = getTableIndexes(tableNumber);
    let notFirstConsecutiveTableNumber = indexToTableNumber(firstIndexes[1] + 1);
    if (firstDetails.consecutiveRare || isDupForced) {
      let n = 2;
      let prevCharacter2 = '';
      while (n < guaranteedCount) {
        const config = configOverride || GACHA_CONFIG[gachaKey];
        const details = getSlotDetails(notFirstConsecutiveTableNumber, gachaKey, '', config, false, prevCharacter2);
        if (!details) break;
        prevCharacter2 = details.rank === 'rare' ? (details.consecutiveRare ? details.nextCharacter : details.character) : '';
        notFirstConsecutiveTableNumber = details.nextTableNumber;
        n++;
      }
    }

    const indexes = getTableIndexes(calculateTableNumber);
    if (!indexes || indexes[0] >= seedProcessor.allSeeds.length || indexes[1] >= seedProcessor.allSeeds.length) {
      return null;
    }
    const config = configOverride || GACHA_CONFIG[gachaKey];
    const charSeed = seedProcessor.allSeeds[indexes[0]];
    const guaranteedCharacters = config.characters[2];
    const charIndex = charSeed % guaranteedCharacters.length;
    const character = guaranteedCharacters[charIndex];
    const nextTableNumber = indexToTableNumber(indexes[1]);

    //レア被り確定枠用
    const indexes2 = getTableIndexes(notFirstConsecutiveTableNumber);
    if (!indexes2 || indexes2[0] >= seedProcessor.allSeeds.length || indexes2[1] >= seedProcessor.allSeeds.length) {
      return null;
    }
    const charSeed2 = seedProcessor.allSeeds[indexes2[0]];
    const charIndex2 = charSeed2 % guaranteedCharacters.length;
    const character2 = guaranteedCharacters[charIndex2];
    const nextTableNumber2 = indexToTableNumber(indexes2[1]);

    let color = '';
    let bgColor = '';
    if (specialCharacters.includes(character) || (firstDetails.consecutiveRare && specialCharacters.includes(character2))) {
      bgColor = 'aqua';
    }

    return {
      tableNumber,
      charSeed,
      character,
      charIndex,
      gachaKey: gachaKey,
      nextTableNumber,
      charSeed2,
      character2,
      charIndex2,
      nextTableNumber2,
      consecutiveRare: firstDetails.consecutiveRare || isDupForced,
      bgColor,
      color,
    };
  }

  // ==================== 超激新規機能 ====================
  // 超激新規用の新キャラ設定作成
  function createNewCharacterConfig(baseConfig) {
    // ディープコピー
    const newConfig = JSON.parse(JSON.stringify(baseConfig));

    // 配列先頭に"新キャラ"を追加
    if (newConfig.characters && newConfig.characters[2]) {
      newConfig.characters[2] = ['新キャラ', ...newConfig.characters[2]];
    }

    return newConfig;
  }

  // 超激新規が有効かどうかを判定
  function isNewCharacterEnabled(gachaKey, type) {
    const checkboxId = type === 'current' ? 'current_gacha_new' : type === 'compare' ? 'compare_gacha_new' : 'compare_gacha2_new';
    const checkbox = document.getElementById(checkboxId);
    return checkbox && checkbox.checked;
  }

  // 超激伝説2倍が有効かどうかを判定
  function isTwiceRateEnabled(gachaKey, type) {
    const checkboxId = type === 'current' ? 'current_gacha_twice' : type === 'compare' ? 'compare_gacha_twice' : 'compare_gacha2_twice';
    const checkbox = document.getElementById(checkboxId);
    return checkbox && checkbox.checked;
  }

  // 超激伝説2倍用の設定作成
  function createTwiceRateConfig(baseConfig) {
    // ディープコピー
    const newConfig = JSON.parse(JSON.stringify(baseConfig));

    // rateをtwiceRateに置き換え
    if (newConfig.twiceRate) {
      newConfig.rate = [...newConfig.twiceRate];
    }

    return newConfig;
  }

  // ガチャ設定を取得
  function getGachaConfig(gachaKey, type) {
    const baseConfig = GACHA_CONFIG[gachaKey];
    if (!baseConfig) return null;

    let config = baseConfig;

    // 超激伝説2倍が有効な場合
    if (isTwiceRateEnabled(gachaKey, type)) {
      config = createTwiceRateConfig(config);
    }

    // 超激新規が有効な場合
    if (isNewCharacterEnabled(gachaKey, type)) {
      config = createNewCharacterConfig(config);
    }

    return config;
  }
  // ==================== 被り検出機能 ====================
  // 全てのガチャ組み合わせでの被り検出
  function detectAllGachaCollisions(consecutivePairs) {
    const allCollisions = [];
    collisionData.clear();

    // 有効なガチャキーを取得
    const activeGachas = [
      { key: currentGachaKey, name: GACHA_CONFIG[currentGachaKey]?.name || '', type: 'current' },
      ...(compareGachaKey ? [{ key: compareGachaKey, name: GACHA_CONFIG[compareGachaKey]?.name || '', type: 'compare1' }] : []),
      ...(compareGachaKey2 ? [{ key: compareGachaKey2, name: GACHA_CONFIG[compareGachaKey2]?.name || '', type: 'compare2' }] : []),
    ];

    // 各ガチャの組み合わせで被り検出
    for (let i = 0; i < activeGachas.length; i++) {
      for (let j = i; j < activeGachas.length; j++) {
        const gacha1 = activeGachas[i];
        const gacha2 = activeGachas[j];

        if (i === j) {
          // 同一ガチャ内での被り
          const collisions = detectSameGachaCollisions(consecutivePairs, gacha1);
          allCollisions.push(...collisions);
        } else {
          // 異なるガチャ間での被り
          const collisions = detectCrossGachaCollisionsBetween(consecutivePairs, gacha1, gacha2);
          allCollisions.push(...collisions);
        }
      }
    }

    return allCollisions;
  }
  // 同一ガチャ内での被り検出
  function detectSameGachaCollisions(consecutivePairs, gacha) {
    const collisions = [];

    consecutivePairs.forEach(([table1, table2]) => {
      const table1Details = getSlotDetails(table1, gacha.key);
      const table2Details = getSlotDetails(table2, gacha.key);

      if (!table1Details || !table2Details) return;

      if (table1Details.character === table2Details.character && table1Details.rank === 'rare') {
        collisions.push([table1, table2]);

        const collisionInfo = {
          currentTable: table1,
          currentChar: table1Details.character,
          collisionTable: table2,
          collisionChar: table2Details.character,
          type: '同一ガチャ内被り',
          currentGachaName: gacha.name,
          collisionGachaName: gacha.name,
          gachaType: gacha.type,
        };

        collisionData.set(table1, collisionInfo);
        collisionData.set(table2, {
          ...collisionInfo,
          currentTable: table2,
          collisionTable: table1,
        });
      }
    });

    return collisions;
  }

  // 異なるガチャ間での被り検出
  function detectCrossGachaCollisionsBetween(consecutivePairs, gacha1, gacha2) {
    const collisions = [];

    consecutivePairs.forEach(([table1, table2]) => {
      const gacha1Table1Details = getSlotDetails(table1, gacha1.key);
      const gacha1Table2Details = getSlotDetails(table2, gacha1.key);
      const gacha2Table1Details = getSlotDetails(table1, gacha2.key);
      const gacha2Table2Details = getSlotDetails(table2, gacha2.key);

      if (!gacha1Table1Details || !gacha1Table2Details || !gacha2Table1Details || !gacha2Table2Details) return;

      // table1のガチャ1とtable2のガチャ2での被り
      if (gacha1Table1Details.character === gacha2Table2Details.character && gacha1Table1Details.rank === 'rare' && gacha2Table2Details.rank === 'rare') {
        collisions.push([table1, table2]);

        const collisionInfo1 = {
          currentTable: table1,
          currentChar: gacha1Table1Details.character,
          collisionTable: table2,
          collisionChar: gacha2Table2Details.character,
          type: 'クロスガチャ被り',
          currentGachaName: gacha1.name,
          collisionGachaName: gacha2.name,
          gachaType: `${gacha1.type}-${gacha2.type}`,
        };

        const collisionInfo2 = {
          currentTable: table2,
          currentChar: gacha2Table2Details.character,
          collisionTable: table1,
          collisionChar: gacha1Table1Details.character,
          type: 'クロスガチャ被り',
          currentGachaName: gacha2.name,
          collisionGachaName: gacha1.name,
          gachaType: `${gacha2.type}-${gacha1.type}`,
        };

        collisionData.set(table1, collisionInfo1);
        collisionData.set(table2, collisionInfo2);
      }

      // table2のガチャ1とtable1のガチャ2での被り
      if (gacha1Table2Details.character === gacha2Table1Details.character && gacha1Table2Details.rank === 'rare' && gacha2Table1Details.rank === 'rare') {
        collisions.push([table2, table1]);

        const collisionInfo1 = {
          currentTable: table2,
          currentChar: gacha1Table2Details.character,
          collisionTable: table1,
          collisionChar: gacha2Table1Details.character,
          type: 'クロスガチャ被り',
          currentGachaName: gacha1.name,
          collisionGachaName: gacha2.name,
          gachaType: `${gacha1.type}-${gacha2.type}`,
        };

        const collisionInfo2 = {
          currentTable: table1,
          currentChar: gacha2Table1Details.character,
          collisionTable: table2,
          collisionChar: gacha1Table2Details.character,
          type: 'クロスガチャ被り',
          currentGachaName: gacha2.name,
          collisionGachaName: gacha1.name,
          gachaType: `${gacha2.type}-${gacha1.type}`,
        };

        collisionData.set(table2, collisionInfo1);
        collisionData.set(table1, collisionInfo2);
      }
    });

    return collisions;
  }

  // ==================== レアスコア判定機能 ====================
  // レアスコアのカテゴリ判定
  function getRareScoreCategory(rareScore) {
    const blueColor = '#4a90e2';

    if (rareScore > 8939 && rareScore <= 8969) {
      return {
        category: 'ultra_legend_double',
        message: '超激・伝説2倍で超激レアに昇格',
        color: blueColor,
      };
    } else if (rareScore > 8969 && rareScore <= 9069) {
      return {
        category: 'ultra_cat_festival',
        message: '超極ネコ祭で超激レアに昇格',
        color: blueColor,
      };
    } else if (rareScore > 9069 && rareScore <= 9469) {
      return {
        category: 'cat_festival',
        message: '超ネコ祭/極ネコ祭で超激レアに昇格',
        color: blueColor,
      };
    } else if (rareScore > 9469 && rareScore <= 9499) {
      return {
        category: 'natural_ultra',
        message: '注：通常時から超激レア',
        color: blueColor,
      };
    } else if (rareScore > 9939 && rareScore <= 9969) {
      return {
        category: 'legend_double',
        message: '伝説2倍で伝説レアに昇格',
        color: blueColor,
      };
    }
    return null;
  }

  let rareScoreData = new Map();

  // レアスコア昇格対象を検出
  function detectRareScorePromotions() {
    rareScoreData.clear();

    for (let i = 0; i < seedProcessor.allSeeds.length; i += 1) {
      if (i >= seedProcessor.allSeeds.length) break;

      const rareSeed = seedProcessor.allSeeds[i];
      const rareScore = rareSeed % 10000;
      const category = getRareScoreCategory(rareScore);

      if (category) {
        const tableNumber = indexToTableNumber(i);

        const data = {
          tableNumber: tableNumber,
          rareSeed: rareSeed,
          rareScore: rareScore,
          category: category.category,
          message: category.message,
          color: category.color,
        };

        rareScoreData.set(tableNumber, data);
      }
    }

    console.log(`レアスコア昇格対象: ${rareScoreData.size}個`);
  }
  // レアスコアセルをハイライト
  function highlightRareScoreCells() {
    const allTds = document.querySelectorAll('td');
    let highlightedCount = 0;

    allTds.forEach((td) => {
      const cellText = td.textContent.trim();
      const rareScoreInfo = rareScoreData.get(cellText);

      if (rareScoreInfo) {
        // 既存のレア被りハイライトがある場合は上書きしない
        if (td.style.backgroundColor !== 'rgb(255, 0, 0)' && td.style.backgroundColor !== '#ff0000') {
          td.style.backgroundColor = rareScoreInfo.color;
          td.style.color = '#ffffff';
          td.style.fontWeight = 'bold';
          td.style.cursor = 'pointer';
          addRareScoreClickEvents(td, cellText);
          highlightedCount++;
        }
      }
    });

    console.log(`${highlightedCount}個のレアスコア昇格セルをハイライト`);
  }
  // レアスコアクリックイベントを追加
  function addRareScoreClickEvents(element, tableNumber) {
    const newElement = element.cloneNode(true);
    element.parentNode.replaceChild(newElement, element);

    newElement.addEventListener('click', function (e) {
      e.preventDefault();
      e.stopPropagation();

      const data = rareScoreData.get(tableNumber);
      if (!data) return;

      const message = `${data.message}`;

      showModernPopup(message, newElement);
    });
  }
  // ==================== テーブル巻き戻し機能 ====================
  // 巻き戻しシードを計算
  function calculateRollbackSeed() {
    const rollbackInput = document.getElementById('rollback_steps');
    const resultSpan = document.getElementById('rollback_result');
    const rollbackLink = document.getElementById('rollback_link');

    if (!rollbackInput || !resultSpan || !rollbackLink) return;

    const rollbackSteps = parseInt(rollbackInput.value);
    if (isNaN(rollbackSteps) || rollbackSteps < 0) {
      resultSpan.textContent = '';
      rollbackLink.style.display = 'none';
      return;
    }

    const actualSteps = rollbackSteps * 2; // 1なら2ステップ、2なら4ステップ...
    const calculatedSeed = reverseXorshift32(currentSeed, actualSteps);

    resultSpan.textContent = calculatedSeed;
    rollbackLink.style.display = 'inline';

    // リンクのクリックイベント設定
    rollbackLink.onclick = function (e) {
      e.preventDefault();
      const currentUrl = new URL(window.location.href);
      currentUrl.searchParams.set('seed', calculatedSeed);
      window.location.href = currentUrl.toString();
    };
  }

  // ==================== ガチャ選択オプション生成機能 ====================
  // ガチャ選択オプションを作成
  function createGachaSelectOptions(excludeKeys = [], includeNone = false) {
    let options = '';
    if (includeNone) {
      options += '<option value="">選択なし</option>';
    }

    options += Object.entries(GACHA_CONFIG)
      .map(([key, config]) => {
        if (config.disabled) {
          return `<option value="${key}" disabled style="color: #999; font-style: italic;">${config.name}</option>`;
        }
        if (excludeKeys.includes(key)) {
          return '';
        }
        return `<option value="${key}">${config.name}</option>`;
      })
      .join('');

    return options;
  }

  // ガチャ選択UIを更新
  function updateGachaSelectOptions() {
    const currentGachaSelect = document.getElementById('current_gacha_select');
    const compareGachaSelect = document.getElementById('compare_gacha_select');
    const compareGachaSelect2 = document.getElementById('compare_gacha_select2');

    if (!currentGachaSelect || !compareGachaSelect || !compareGachaSelect2) return;

    const currentValue = currentGachaSelect.value;
    const compareValue = compareGachaSelect.value;
    const compare2Value = compareGachaSelect2.value;

    // 現在のガチャの選択肢
    const currentExclude = [compareValue, compare2Value].filter((v) => v && !GACHA_CONFIG[v]?.disabled);
    currentGachaSelect.innerHTML = createGachaSelectOptions(currentExclude, false);
    currentGachaSelect.value = currentValue;

    // 被り確認用ガチャ①
    const compareExclude = [currentValue, compare2Value].filter((v) => v && !GACHA_CONFIG[v]?.disabled);
    compareGachaSelect.innerHTML = createGachaSelectOptions(compareExclude, true);
    compareGachaSelect.value = compareValue;

    // 被り確認用ガチャ②
    const compare2Exclude = [currentValue, compareValue].filter((v) => v && !GACHA_CONFIG[v]?.disabled);
    compareGachaSelect2.innerHTML = createGachaSelectOptions(compare2Exclude, true);
    compareGachaSelect2.value = compare2Value;
  }

  // ガチャ設定を更新
  function updateGachaSettings() {
    const currentGachaSelect = document.getElementById('current_gacha_select');
    const compareGachaSelect = document.getElementById('compare_gacha_select');
    const compareGachaSelect2 = document.getElementById('compare_gacha_select2');

    // 現在の選択値を取得
    const currentValue = currentGachaSelect?.value;
    const compareValue = compareGachaSelect?.value;
    const compare2Value = compareGachaSelect2?.value;

    // 重複チェック・自動調整
    if (currentValue && compareValue && currentValue === compareValue) {
      const alternativeGacha = findAlternativeGacha([currentValue, compare2Value]);
      if (alternativeGacha) {
        compareGachaSelect.value = alternativeGacha;
      }
    }

    if (currentValue && compare2Value && currentValue === compare2Value) {
      const alternativeGacha = findAlternativeGacha([currentValue, compareValue]);
      if (alternativeGacha) {
        compareGachaSelect2.value = alternativeGacha;
      }
    }

    if (compareValue && compare2Value && compareValue === compare2Value) {
      const alternativeGacha = findAlternativeGacha([currentValue, compareValue]);
      if (alternativeGacha) {
        compareGachaSelect2.value = alternativeGacha;
      }
    }

    // 最終的な値を設定
    if (currentGachaSelect) currentGachaKey = currentGachaSelect.value;
    if (compareGachaSelect) compareGachaKey = compareGachaSelect.value || '';
    if (compareGachaSelect2) compareGachaKey2 = compareGachaSelect2.value || '';

    // 選択なしの場合はチェックボックスを無効化
    const compareGachaSingle = document.getElementById('compare_gacha_single');
    const compareGachaEleven = document.getElementById('compare_gacha_eleven');
    const compareGacha2Single = document.getElementById('compare_gacha2_single');
    const compareGacha2Eleven = document.getElementById('compare_gacha2_eleven');

    if (compareGachaSingle && compareGachaEleven) {
      const isCompareSelected = !!compareGachaKey;
      compareGachaSingle.disabled = !isCompareSelected;
      compareGachaEleven.disabled = !isCompareSelected;
      if (!isCompareSelected) {
        compareGachaSingle.checked = false;
        compareGachaEleven.checked = false;
      } else {
        // ガチャが選択されている場合、単発は初期状態でチェック済み（ただし既にfalseの場合は維持）
        if (!compareGachaSingle.hasAttribute('data-user-modified')) {
          compareGachaSingle.checked = true;
        }
      }
    }

    if (compareGacha2Single && compareGacha2Eleven) {
      const isCompare2Selected = !!compareGachaKey2;
      compareGacha2Single.disabled = !isCompare2Selected;
      compareGacha2Eleven.disabled = !isCompare2Selected;
      if (!isCompare2Selected) {
        compareGacha2Single.checked = false;
        compareGacha2Eleven.checked = false;
      } else {
        // ガチャが選択されている場合、単発は初期状態でチェック済み（ただし既にfalseの場合は維持）
        if (!compareGacha2Single.hasAttribute('data-user-modified')) {
          compareGacha2Single.checked = true;
        }
      }
    }

    updateGachaLabels();

    // オリジナルテーブルが表示されている場合
    const tableTypeSelect = document.getElementById('table_type_select');
    if (tableTypeSelect && tableTypeSelect.value === 'original') {
      resetOriginalTableHighlights();
      // 再計算を実行
      updateOriginalTableData();
    } else {
      // デフォルトテーブルの場合
      resetHighlights();
      highlightRareCollisions();
    }
  }
  // オリジナルテーブル専用のハイライトリセット関数
  function resetOriginalTableHighlights() {
    const customTable = document.querySelector('.custom-table');
    if (!customTable) return;

    const customTds = customTable.querySelectorAll('td');
    customTds.forEach((td) => {
      // ハイライトが適用されているセルをリセット
      if (td.style.backgroundColor === 'rgb(255, 0, 0)' || td.style.backgroundColor === '#ff0000' || td.style.backgroundColor === '#4a90e2' || td.style.backgroundColor === 'rgb(74, 144, 226)') {
        const newTd = td.cloneNode(true);
        newTd.style.backgroundColor = '';
        newTd.style.color = '';
        newTd.style.fontWeight = '';
        newTd.style.cursor = '';
        td.parentNode.replaceChild(newTd, td);
      }
    });

    // データもクリア
    collisionData.clear();
    rareScoreData.clear();
  }
  // ガチャラベルを更新
  function updateGachaLabels() {
    const currentGachaName = GACHA_CONFIG[currentGachaKey] ? GACHA_CONFIG[currentGachaKey].name : '現在のガチャ';
    const compareGachaName = compareGachaKey && GACHA_CONFIG[compareGachaKey] ? GACHA_CONFIG[compareGachaKey].name : '被り確認①';
    const compareGachaName2 = compareGachaKey2 && GACHA_CONFIG[compareGachaKey2] ? GACHA_CONFIG[compareGachaKey2].name : '被り確認②';

    // オリジナルテーブル選択時のラベルを更新
    const currentLabel = document.getElementById('current_gacha_label');
    if (currentLabel) currentLabel.textContent = currentGachaName;

    const compareLabel = document.getElementById('compare_gacha_label');
    if (compareLabel) compareLabel.textContent = compareGachaName;

    const compareLabel2 = document.getElementById('compare_gacha2_label');
    if (compareLabel2) compareLabel2.textContent = compareGachaName2;

    // 被り確認用ガチャの表示/非表示制御
    const compareSettings = document.getElementById('compare_gacha_settings');
    const compare2Settings = document.getElementById('compare_gacha2_settings');

    if (compareSettings) {
      compareSettings.style.display = compareGachaKey ? 'block' : 'none';
    }
    if (compare2Settings) {
      compare2Settings.style.display = compareGachaKey2 ? 'block' : 'none';
    }

    // 超激伝説2倍チェックボックスの表示/非表示制御
    updateTwiceRateCheckboxVisibility();

    // オリジナルテーブルのヘッダーも更新
    updateTableHeader();
  }
  function updateTwiceRateCheckboxVisibility() {
    // 現在のガチャ
    const currentTwiceLabel = document.getElementById('current_gacha_twice_label');
    if (currentTwiceLabel) {
      const currentConfig = GACHA_CONFIG[currentGachaKey];
      if (currentConfig && currentConfig.twiceRate) {
        currentTwiceLabel.style.display = 'flex';
      } else {
        currentTwiceLabel.style.display = 'none';
        // チェックを外す
        const currentTwiceCheckbox = document.getElementById('current_gacha_twice');
        if (currentTwiceCheckbox) currentTwiceCheckbox.checked = false;
      }
    }

    // 被り確認用ガチャ①
    const compareTwiceLabel = document.getElementById('compare_gacha_twice_label');
    if (compareTwiceLabel) {
      const compareConfig = GACHA_CONFIG[compareGachaKey];
      if (compareConfig && compareConfig.twiceRate) {
        compareTwiceLabel.style.display = 'flex';
      } else {
        compareTwiceLabel.style.display = 'none';
        // チェックを外す
        const compareTwiceCheckbox = document.getElementById('compare_gacha_twice');
        if (compareTwiceCheckbox) compareTwiceCheckbox.checked = false;
      }
    }

    // 被り確認用ガチャ②
    const compare2TwiceLabel = document.getElementById('compare_gacha2_twice_label');
    if (compare2TwiceLabel) {
      const compare2Config = GACHA_CONFIG[compareGachaKey2];
      if (compare2Config && compare2Config.twiceRate) {
        compare2TwiceLabel.style.display = 'flex';
      } else {
        compare2TwiceLabel.style.display = 'none';
        // チェックを外す
        const compare2TwiceCheckbox = document.getElementById('compare_gacha2_twice');
        if (compare2TwiceCheckbox) compare2TwiceCheckbox.checked = false;
      }
    }
  }
  // 代替ガチャを検索
  function findAlternativeGacha(excludeKeys) {
    const availableGachas = Object.keys(GACHA_CONFIG).filter((key) => !GACHA_CONFIG[key].disabled && !excludeKeys.includes(key));
    return availableGachas.length > 0 ? availableGachas[0] : null;
  }

  // ==================== UI関連機能 ====================
  // 拡張機能UIを追加
  function addGachaSelectionUI() {
    const formDiv = document.querySelector('div.form');

    if (!formDiv) {
      console.log('form divが見つかりません');
      return;
    }

    const gachaSelectionDiv = document.createElement('div');
    gachaSelectionDiv.style.cssText = `
        margin-top: 10px;
        padding: 15px;
        border: 1px solid #ccc;
        border-radius: 8px;
        background-color: #f9f9f9;
        max-width: 1068px
    `;

    const options = createGachaSelectOptions();
    gachaSelectionDiv.innerHTML = `
        <div style="margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; border-bottom: 2px solid #007bff; padding-bottom: 8px;">
            <span style="font-weight: bold; font-size: 16px; color: #333;">拡張機能</span>
            <span style="font-size: 14px; color: #666; font-weight: normal;">更新：${currentDate}</span>
        </div>

        <div style="margin-bottom: 10px;">
            <div style="font-weight: bold; margin-bottom: 6px; color: #333; font-size: 16px;">テーブル巻き戻し</div>
            <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <label for="rollback_steps" style="font-weight: bold; white-space: nowrap; font-size: 16px; margin:0px">巻き戻し回数:</label>
                    <input type="number" id="rollback_steps" min="0" max="1000" style="width: 80px; padding: 5px; border: 1px solid #ddd; border-radius: 4px;margin:0px" placeholder="0">
                    <button id="calculate_rollback" style="background: rgb(0, 123, 255); margin-bottom:0px; color: white; border: none; border-radius: 6px; padding: 0px 16px; font-size: 12px; cursor: pointer; font-weight: bold; transition: background-color 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">算出</button>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-weight: bold; font-size: 16px;">算出シード:</span>
                    <span id="rollback_result" style="font-family: monospace; font-weight: bold; color: #2c3e50; background: #ecf0f1; padding: 4px 8px; border-radius: 4px; min-width: 80px; display: inline-block; font-size: 16px;"></span>
                    <a href="#" id="rollback_link" style="display: none; color: #007bff; text-decoration: none; font-weight: bold; padding: 4px 10px; background: #e8f4f8; border-radius: 4px; border: 1px solid #007bff; transition: all 0.2s; font-size: 13px; padding: 0px 8px;">遷移</a>
                </div>
            </div>
        </div>

        <div style="margin-bottom: 10px;">
            <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 8px; margin-bottom: 6px;">
                <div style="font-weight: bold; color: #333; font-size: 16px;">シード保存</div>
                <button id="save_seed_button" style="background: rgb(0, 123, 255); color: white; border: none; border-radius: 6px; margin:0px; padding: 0px 16px; font-size: 12px; cursor: pointer; font-weight: bold; transition: background-color 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    現在のシードを保存
                </button>
            </div>
            <div style="font-weight: bold; font-size: 14px; color: #333; margin-bottom: 6px;">
                保存済みのシード (最大10件):
            </div>
            <div id="seed-list" style="display: flex; flex-wrap: wrap; gap: 8px;">
                <span style="color: #666; font-style: italic; font-size: 14px;">保存済みのシードはありません</span>
            </div>
        </div>

   <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 15px;">
        <div style="min-width: 0;">
            <label for="current_gacha_select" style="display: block; margin-bottom: 5px; font-weight: bold; font-size:16px">現在のガチャ:</label>
            <select id="current_gacha_select" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; min-width: 0;">
                ${options}
            </select>
        </div>
        <div style="min-width: 0;">
            <label for="compare_gacha_select" style="display: block; margin-bottom: 5px; font-weight: bold; font-size:16px">被り確認用ガチャ①:</label>
            <select id="compare_gacha_select" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; min-width: 0;">
                <option value="">選択なし</option>
                ${options}
            </select>
        </div>
        <div style="min-width: 0;">
            <label for="compare_gacha_select2" style="display: block; margin-bottom: 5px; font-weight: bold; font-size:16px">被り確認用ガチャ②:</label>
            <select id="compare_gacha_select2" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; min-width: 0;">
                <option value="">選択なし</option>
                ${options}
            </select>
        </div>
    </div>


<div style="margin-bottom: 15px;">
    <label for="table_type_select" style="display: block; margin-bottom: 5px; font-weight: bold; font-size:16px">テーブル設定:</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <select id="table_type_select" style="width: 200px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="default">デフォルト</option>
            <option value="original">オリジナル</option>
        </select>
        <div id="plan_mode_toggle" style="display: none;">
            <select id="plan_mode_select" style="width: 150px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                <option value="normal">通常モード</option>
                <option value="plan">計画モード</option>
            </select>
        </div>
    </div>
</div>

        <!-- オリジナルテーブル選択時のオプション -->
    <div id="original_table_options" style="display: none; margin-bottom: 15px;">
        <div style="font-weight: bold; font-size: 16px; color: #333; margin-bottom: 16px; padding-bottom: 8px; border-bottom: 1px solid #ddd;">
            ガチャ表示設定
        </div>
        <div style="display: grid;  gap: 16px;">
<!-- 現在のガチャ設定 -->
<div style="padding: 16px; border: 1px solid #e0e0e0; border-radius: 8px; ">
    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: #2c3e50; display: flex; align-items: center; gap: 8px;">
        <div style="width: 4px; height: 20px; background: #3498db; border-radius: 2px;"></div>
        <span id="current_gacha_label">現在のガチャ</span>
    </div>
    <div style="display: flex; gap: 16px; flex-wrap: wrap;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; white-space: nowrap;">
            <input type="checkbox" id="current_gacha_single" checked disabled style="cursor: not-allowed;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">単発</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; hover:background-color: #f8f9fa; white-space: nowrap;">
            <input type="checkbox" id="current_gacha_eleven" style="cursor: pointer; accent-color: #3498db;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">確定</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; hover:background-color: #f8f9fa; white-space: nowrap;">
            <input type="checkbox" id="current_gacha_new" style="cursor: pointer; accent-color: #3498db;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">超激新規</span>
        </label>
        <label id="current_gacha_twice_label" style="display: none; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; hover:background-color: #f8f9fa; white-space: nowrap;">
            <input type="checkbox" id="current_gacha_twice" style="cursor: pointer; accent-color: #3498db;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">超激伝説2倍</span>
        </label>
    </div>
</div>

<!-- 被り確認用ガチャ①設定 -->
<div id="compare_gacha_settings" style="padding: 16px; border: 1px solid #e0e0e0; border-radius: 8px;">
    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: #2c3e50; display: flex; align-items: center; gap: 8px;">
        <div style="width: 4px; height: 20px; background: #e74c3c; border-radius: 2px;"></div>
        <span id="compare_gacha_label">被り確認用ガチャ①</span>
    </div>
    <div style="display: flex; gap: 16px; flex-wrap: wrap;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; hover:background-color: #f8f9fa; white-space: nowrap;">
            <input type="checkbox" id="compare_gacha_single" checked style="cursor: pointer; accent-color: #e74c3c;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">単発</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; hover:background-color: #f8f9fa; white-space: nowrap;">
            <input type="checkbox" id="compare_gacha_eleven" style="cursor: pointer; accent-color: #e74c3c;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">確定</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; hover:background-color: #f8f9fa; white-space: nowrap;">
            <input type="checkbox" id="compare_gacha_new" style="cursor: pointer; accent-color: #e74c3c;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">超激新規</span>
        </label>
        <label id="compare_gacha_twice_label" style="display: none; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; hover:background-color: #f8f9fa; white-space: nowrap;">
            <input type="checkbox" id="compare_gacha_twice" style="cursor: pointer; accent-color: #e74c3c;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">超激伝説2倍</span>
        </label>
    </div>
</div>

            <!-- 被り確認用ガチャ②設定 -->
<div id="compare_gacha2_settings" style="padding: 16px; border: 1px solid #e0e0e0; border-radius: 8px; ">
    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: #2c3e50; display: flex; align-items: center; gap: 8px;">
        <div style="width: 4px; height: 20px; background: #f39c12; border-radius: 2px;"></div>
        <span id="compare_gacha2_label">被り確認用ガチャ②</span>
    </div>
    <div style="display: flex; gap: 16px; flex-wrap: wrap;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; hover:background-color: #f8f9fa; white-space: nowrap;">
            <input type="checkbox" id="compare_gacha2_single" checked style="cursor: pointer; accent-color: #f39c12;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">単発</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; hover:background-color: #f8f9fa; white-space: nowrap;">
            <input type="checkbox" id="compare_gacha2_eleven" style="cursor: pointer; accent-color: #f39c12;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">確定</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; hover:background-color: #f8f9fa; white-space: nowrap;">
            <input type="checkbox" id="compare_gacha2_new" style="cursor: pointer; accent-color: #f39c12;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">超激新規</span>
        </label>
        <label id="compare_gacha2_twice_label" style="display: none; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; border-radius: 6px; background: white; border: 1px solid #dee2e6; transition: all 0.2s; hover:background-color: #f8f9fa; white-space: nowrap;">
            <input type="checkbox" id="compare_gacha2_twice" style="cursor: pointer; accent-color: #f39c12;">
            <span style="font-weight: 500; font-size: 14px; color: #495057;">超激伝説2倍</span>
        </label>
    </div>
</div>
        </div>
    </div>

        <div style="margin-bottom: 15px; padding: 12px; border: 1px solid #ddd; border-radius: 6px; background-color: #f9f9f9;">
            <div id="color_legend_content" style="display: flex; flex-wrap: wrap; gap: 15px; font-size: 14px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div class="loading-spinner" style="width: 16px; height: 16px; border: 2px solid #f3f3f3; border-top: 2px solid #007bff; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    <span>シード計算中...</span>
                </div>
            </div>
        </div>

        <div style="margin-top: 15px; display: flex; gap: 20px;">
            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                <input type="checkbox" id="hide_confirmed_columns" style="cursor: pointer;">
                <span style="font-weight: bold; font-size:16px">確定列を最小化</span>
            </label>
            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                <input type="checkbox" id="expand_table" style="cursor: pointer;">
                <span style="font-weight: bold; font-size:16px">表を拡張</span>
            </label>
        </div>

         <style>
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
            #calculate_rollback:hover, #save_seed_button:hover {
                background: rgb(0, 86, 179) !important;
            }
            #rollback_link:hover {
                background: #d4edff !important;
                border-color: #0056b3 !important;
            }
            /* シンプルなホバー効果 */
            label:has(input[type="checkbox"]):hover {
                background-color: #f0f0f0;
            }
        </style>
    `;

    // DOMに要素を追加
    formDiv.parentNode.insertBefore(gachaSelectionDiv, formDiv.nextSibling);

    // 初期値を設定
    document.getElementById('current_gacha_select').value = currentGachaKey;
    document.getElementById('compare_gacha_select').value = ''; // 初期値を空に
    document.getElementById('compare_gacha_select2').value = ''; // 初期値を空に

    // 初期状態で選択肢を更新
    updateGachaSelectOptions();

    // イベントリスナーを設定
    setupEventListeners();

    // 初期シードリストを更新
    const savedSeeds = getSavedSeeds();
    const seedList = document.getElementById('seed-list');
    updateSeedList(seedList, savedSeeds);
  }
  // イベントリスナーを設定
  function setupEventListeners() {
    // テーブル設定
    const tableTypeSelect = document.getElementById('table_type_select');
    if (tableTypeSelect) {
      tableTypeSelect.addEventListener('change', updateTableSettings);
    }

    // ガチャ選択変更時
    const currentGachaSelect = document.getElementById('current_gacha_select');
    if (currentGachaSelect) {
      currentGachaSelect.addEventListener('change', () => {
        if (isPlanMode && !shouldResetWithAlert()) {
          // リセットしない場合は元の値に戻す
          currentGachaSelect.value = currentGachaKey;
          return;
        }
        if (isPlanMode) clearAllSelections();
        updateGachaSettings();
        updateGachaSelectOptions();
      });
    }

    const compareGachaSelect = document.getElementById('compare_gacha_select');
    if (compareGachaSelect) {
      compareGachaSelect.addEventListener('change', () => {
        if (isPlanMode && !shouldResetWithAlert()) {
          compareGachaSelect.value = compareGachaKey;
          return;
        }
        if (isPlanMode) clearAllSelections();
        updateGachaSettings();
        updateGachaSelectOptions();
      });
    }

    const compareGachaSelect2 = document.getElementById('compare_gacha_select2');
    if (compareGachaSelect2) {
      compareGachaSelect2.addEventListener('change', () => {
        if (isPlanMode && !shouldResetWithAlert()) {
          compareGachaSelect2.value = compareGachaKey2;
          return;
        }
        if (isPlanMode) clearAllSelections();
        updateGachaSettings();
        updateGachaSelectOptions();
      });
    }
    // チェックボックスにもリセット確認を追加
    const checkboxes = [
      'current_gacha_single',
      'current_gacha_eleven',
      'current_gacha_new',
      'current_gacha_twice',
      'compare_gacha_single',
      'compare_gacha_eleven',
      'compare_gacha_new',
      'compare_gacha_twice',
      'compare_gacha2_single',
      'compare_gacha2_eleven',
      'compare_gacha2_new',
      'compare_gacha2_twice',
    ];
    checkboxes.forEach((id) => {
      const checkbox = document.getElementById(id);
      if (checkbox) {
        checkbox.addEventListener('change', (e) => {
          if (isPlanMode && !shouldResetWithAlert()) {
            // リセットしない場合は元の状態に戻す
            e.target.checked = !e.target.checked;
            return;
          }
          if (isPlanMode) clearAllSelections();

          if (id.includes('single') && id.includes('compare')) {
            e.target.setAttribute('data-user-modified', 'true');
          }
          toggleGuaranteedColumns();
          updateGachaSettings();
        });
      }
    });

    // 現在のガチャのチェックボックス
    const currentGachaSingle = elementCache.get('current_gacha_single');
    if (currentGachaSingle) {
      currentGachaSingle.addEventListener('change', () => {
        toggleGuaranteedColumns();
        updateGachaSettings();
      });
    }

    const currentGachaEleven = elementCache.get('current_gacha_eleven');
    if (currentGachaEleven) {
      currentGachaEleven.addEventListener('change', () => {
        toggleGuaranteedColumns();
        updateGachaSettings();
      });
    }

    // 被り確認用ガチャ①
    const compareGachaSingle = document.getElementById('compare_gacha_single');
    if (compareGachaSingle) {
      compareGachaSingle.addEventListener('change', () => {
        compareGachaSingle.setAttribute('data-user-modified', 'true');
        toggleGuaranteedColumns();
        updateGachaSettings();
      });
    }

    // 被り確認用ガチャ②
    const compareGacha2Single = document.getElementById('compare_gacha2_single');
    if (compareGacha2Single) {
      compareGacha2Single.addEventListener('change', () => {
        compareGacha2Single.setAttribute('data-user-modified', 'true');
        toggleGuaranteedColumns();
        updateGachaSettings();
      });
    }

    // 被り確認用ガチャ①②の確定
    const compareGachaEleven = document.getElementById('compare_gacha_eleven');
    if (compareGachaEleven) {
      compareGachaEleven.addEventListener('change', () => {
        toggleGuaranteedColumns();
        updateGachaSettings();
      });
    }

    const compareGacha2Eleven = document.getElementById('compare_gacha2_eleven');
    if (compareGacha2Eleven) {
      compareGacha2Eleven.addEventListener('change', () => {
        toggleGuaranteedColumns();
        updateGachaSettings();
      });
    }
    // 超激新規チェックボックス
    const currentGachaNew = document.getElementById('current_gacha_new');
    if (currentGachaNew) {
      currentGachaNew.addEventListener('change', updateGachaSettings);
    }

    const compareGachaNew = document.getElementById('compare_gacha_new');
    if (compareGachaNew) {
      compareGachaNew.addEventListener('change', updateGachaSettings);
    }

    const compareGacha2New = document.getElementById('compare_gacha2_new');
    if (compareGacha2New) {
      compareGacha2New.addEventListener('change', updateGachaSettings);
    }

    // 超激伝説2倍チェックボックス
    const currentGachaTwice = document.getElementById('current_gacha_twice');
    if (currentGachaTwice) {
      currentGachaTwice.addEventListener('change', updateGachaSettings);
    }

    const compareGachaTwice = document.getElementById('compare_gacha_twice');
    if (compareGachaTwice) {
      compareGachaTwice.addEventListener('change', updateGachaSettings);
    }

    const compareGacha2Twice = document.getElementById('compare_gacha2_twice');
    if (compareGacha2Twice) {
      compareGacha2Twice.addEventListener('change', updateGachaSettings);
    }
    // 計画モード選択
    const planModeSelect = document.getElementById('plan_mode_select');
    if (planModeSelect) {
      planModeSelect.addEventListener('change', () => {
        isPlanMode = planModeSelect.value === 'plan';
        togglePlanMode();
      });
    }
    // その他の機能
    const hideConfirmedColumns = document.getElementById('hide_confirmed_columns');
    if (hideConfirmedColumns) {
      hideConfirmedColumns.addEventListener('change', toggleConfirmedColumns);
    }

    const expandTable = document.getElementById('expand_table');
    if (expandTable) {
      expandTable.addEventListener('change', toggleTableExpansion);
    }

    const calculateRollback = document.getElementById('calculate_rollback');
    if (calculateRollback) {
      calculateRollback.addEventListener('click', calculateRollbackSeed);
    }

    const saveSeedButton = document.getElementById('save_seed_button');
    if (saveSeedButton) {
      saveSeedButton.addEventListener('click', handleSaveSeed);
    }
  }

  // ヘッダー更新機能
  function updateTableHeader() {
    const customTable = document.querySelector('.custom-table');
    if (!customTable) return;

    const thead = customTable.querySelector('thead');
    if (!thead) return;

    // 既存のヘッダーを削除して新しいヘッダーを作成
    thead.innerHTML = '';
    const newHeader = createTableHeader();
    thead.appendChild(newHeader.firstChild);

    // ヘッダー固定スタイルを再適用
    thead.style.position = 'sticky';
    thead.style.top = '0';
    thead.style.zIndex = '10';
    thead.style.backgroundColor = '#f0f0f0';
  }

  // テーブル設定を更新
  function updateTableSettings() {
    const tableType = document.getElementById('table_type_select').value;
    const originalOptions = document.getElementById('original_table_options');
    const originalTable = document.querySelector('.table');
    const planModeToggle = document.getElementById('plan_mode_toggle');
    const planModeSelect = document.getElementById('plan_mode_select');

    const hideConfirmedCheckbox = document.getElementById('hide_confirmed_columns');
    const expandTableCheckbox = document.getElementById('expand_table');
    const checkboxContainer = hideConfirmedCheckbox.closest('div');

    if (tableType === 'original') {
      // オリジナルテーブル選択時
      originalOptions.style.display = 'block';
      planModeToggle.style.display = 'block';
      if (originalTable) {
        originalTable.style.display = 'none';
      }

      hideConfirmedCheckbox.checked = false;
      expandTableCheckbox.checked = false;
      checkboxContainer.style.display = 'none';

      // 計画モードの初期化
      planModeSelect.value = 'normal';
      isPlanMode = false;

      updateGachaLabels();
      createOriginalTable();
    } else {
      // デフォルトテーブル選択時
      originalOptions.style.display = 'none';
      planModeToggle.style.display = 'none';
      if (originalTable) {
        originalTable.style.display = 'block';
      }

      checkboxContainer.style.display = 'block';

      // 計画モードをリセット
      isPlanMode = false;
      removeTicketCounter();
      removeOriginalTable();
      resetCheckboxes();
    }

    console.log('テーブル設定変更:', tableType);
  }

  // 確定列の表示/非表示切り替え
  function toggleConfirmedColumns() {
    const isHidden = document.getElementById('hide_confirmed_columns').checked;
    const tbody = document.querySelector('tbody');

    if (!tbody) {
      console.log('tbodyが見つかりません');
      return;
    }

    const rows = tbody.querySelectorAll('tr');

    if (rows.length > 0) {
      const firstRow = rows[0];
      const th3 = firstRow.children[2]; // 3番目のth
      const th5 = firstRow.children[4]; // 5番目のth

      if (isHidden) {
        // 3番目と5番目のthを空白文字に変更
        if (th3) th3.textContent = '';
        if (th5) th5.textContent = '';
      } else {
        // 元のテキストに戻す（必要に応じて元の値を設定）
        if (th3) th3.textContent = th3.getAttribute('data-original-text') || 'Guaranteed';
        if (th5) th5.textContent = th5.getAttribute('data-original-text') || 'Alt. guaranteed';
      }
    }
  }
  // 表拡張機能の切り替え
  function toggleTableExpansion() {
    const isExpanded = document.getElementById('expand_table').checked;
    const tbody = document.querySelector('tbody');

    if (!tbody) {
      console.log('tbodyが見つかりません');
      return;
    }

    const rows = tbody.querySelectorAll('tr');

    if (rows.length > 0) {
      const firstRow = rows[0];
      const td2 = firstRow.children[1]; // 2番目のtd
      const td3 = firstRow.children[2]; // 3番目のtd
      const td4 = firstRow.children[3]; // 4番目のtd
      const td5 = firstRow.children[4]; // 5番目のtd

      if (isExpanded) {
        if (td2) td2.style.minWidth = '150px';
        if (td3) td3.style.minWidth = '250px';
        if (td4) td4.style.minWidth = '150px';
        if (td5) td5.style.minWidth = '250px';
        const catTds = document.querySelectorAll('td.cat');
        catTds.forEach((td) => {
          const aElement = td.querySelector('a');
          if (aElement) {
            aElement.style.fontWeight = '600';
          }
        });
      } else {
        if (td2) td2.style.minWidth = '';
        if (td3) td3.style.minWidth = '';
        if (td4) td4.style.minWidth = '';
        if (td5) td5.style.minWidth = '';
        const catTds = document.querySelectorAll('td.cat');
        catTds.forEach((td) => {
          const aElement = td.querySelector('a');
          if (aElement) {
            aElement.style.fontWeight = '';
          }
        });
      }
    }
  }
  // チェックボックスをリセット
  function resetCheckboxes() {
    elementCache.get('current_gacha_single').checked = true;
    elementCache.get('current_gacha_eleven').checked = false;
    elementCache.get('compare_gacha_single').checked = true;
    elementCache.get('compare_gacha_eleven').checked = false;
    elementCache.get('compare_gacha2_single').checked = true;
    elementCache.get('compare_gacha2_eleven').checked = false;
  }

  //==================== オリジナルテーブル作成関数 ====================

  // オリジナルテーブル作成関数
  function createOriginalTable() {
    // 既存のオリジナルテーブルがあれば削除
    removeOriginalTable();

    const originalTable = document.querySelector('.table');
    if (!originalTable) return;

    // カスタムテーブルコンテナを作成
    const customContainer = document.createElement('div');
    customContainer.className = 'custom-table-container';
    customContainer.style.cssText = `
        margin: 20px 0;
        font-family: inherit;
        position: relative;
    `;

    // テーブル作成
    const table = document.createElement('table');
    table.className = 'custom-table';
    table.style.cssText = `
        border-collapse: collapse;
        min-width: 335px;
        font-size: 12px;
    `;

    // ヘッダー作成
    const thead = createTableHeader();

    table.appendChild(thead);

    // ボディ作成
    const tbody = createTableBody();
    table.appendChild(tbody);

    customContainer.appendChild(table);

    // 既存テーブルの後に挿入
    originalTable.parentNode.insertBefore(customContainer, originalTable.nextSibling);

    // 初期表示時
    setTimeout(() => {
      toggleGuaranteedColumns();
      updateOriginalTableData();
    }, 100);
  }

  // テーブルヘッダー作成
  function createTableHeader() {
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');

    // ガチャ名を取得
    const currentGachaName = GACHA_CONFIG[currentGachaKey] ? GACHA_CONFIG[currentGachaKey].name : '現在のガチャ';
    const compareGachaName = compareGachaKey && GACHA_CONFIG[compareGachaKey] ? GACHA_CONFIG[compareGachaKey].name : '被り確認①';
    const compareGachaName2 = compareGachaKey2 && GACHA_CONFIG[compareGachaKey2] ? GACHA_CONFIG[compareGachaKey2].name : '被り確認②';

    const headerStyle = `
        background-color: rgb(44, 62, 80);
        white-space: nowrap;
        color: white;
        font-weight: 600;
        font-size: 14px;
        padding: 10px 5px;
        text-align: center;
        border: none;
        position: sticky;
        top: 0px;
        z-index: 1001;
        letter-spacing: 0.3px;
        transition: background-color 0.2s;
        min-width: 140px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    `;

    // 左右端の列用スタイル（最小幅なし）
    const edgeHeaderStyle = `
        background-color: rgb(44, 62, 80);
        white-space: nowrap;
        color: white;
        font-weight: 600;
        font-size: 14px;
        padding: 10px 5px;
        text-align: center;
        border: none;
        position: sticky;
        top: 0px;
        z-index: 1001;
        letter-spacing: 0.3px;
        transition: background-color 0.2s;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    `;

    const currentGuaranteedCount = fifteenGuaranteedKeys.includes(currentGachaKey) ? 15 : 11;
    const compareGuaranteedCount = fifteenGuaranteedKeys.includes(compareGachaKey) ? 15 : 11;
    const compareGuaranteedCount2 = fifteenGuaranteedKeys.includes(compareGachaKey2) ? 15 : 11;

    headerRow.innerHTML = `
        <th style="${edgeHeaderStyle}">#</th>
        <th style="${headerStyle}">${currentGachaName}</th>
        <th class="compare-column" style="${headerStyle} display: none;">${compareGachaName}</th>
        <th class="compare2-column" style="${headerStyle} display: none;">${compareGachaName2}</th>
        <th class="guaranteed-column" style="${headerStyle} display: none;">${currentGachaName}<br/>確定${currentGuaranteedCount}連</th>
        <th class="guaranteed-compare-column" style="${headerStyle} display: none;">${compareGachaName}<br/>確定${compareGuaranteedCount}連</th>
        <th class="guaranteed-compare2-column" style="${headerStyle} display: none;">${compareGachaName2}<br/>確定${compareGuaranteedCount2}連</th>
        <th class="b-side-start" style="${headerStyle}">${currentGachaName}</th>
        <th class="compare-column" style="${headerStyle} display: none;">${compareGachaName}</th>
        <th class="compare2-column" style="${headerStyle} display: none;">${compareGachaName2}</th>
        <th class="guaranteed-column" style="${headerStyle} display: none;">${currentGachaName}<br/>確定${currentGuaranteedCount}連</th>
        <th class="guaranteed-compare-column" style="${headerStyle} display: none;">${compareGachaName}<br/>確定${compareGuaranteedCount}連</th>
        <th class="guaranteed-compare2-column" style="${headerStyle} display: none;">${compareGachaName2}<br/>確定${compareGuaranteedCount2}連</th>
        <th style="${edgeHeaderStyle}">#</th>
    `;

    thead.appendChild(headerRow);
    return thead;
  }

  // テーブルボディ作成
  function createTableBody() {
    const tbody = document.createElement('tbody');

    // 基本セルスタイル
    const cellStyle = `
        border: 1px solid #ccc;
        padding: 4px;
        text-align: center;
        min-height: 20px;
        line-height: 20px !important;
    `;

    for (let i = 1; i <= count; i++) {
      // 上の行（スコア行）
      const upperRow = document.createElement('tr');
      if (i === 1) {
        upperRow.innerHTML = `
                <td rowspan="2" style="background-color: #f8f8f8; font-weight: bold; ${cellStyle}">${i}A</td>
                <td class="score" id="original-score-${i}A" style="${cellStyle} border-bottom: none;">&nbsp;</td>
                <td class="compare-score compare-column" id="original-compare-score-${i}A" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
                <td class="compare2-score compare2-column" id="original-compare2-score-${i}A" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
                <td class="guaranteed-score guaranteed-column" id="original-guaranteed-score-${i}A" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
                <td class="guaranteed-compare-score guaranteed-compare-column" id="original-guaranteed-compare-score-${i}A" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
                <td class="guaranteed-compare2-score guaranteed-compare2-column" id="original-guaranteed-compare2-score-${i}A" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
                <td class="empty-colspan b-side-start" colspan="6" style="${cellStyle}">&nbsp;</td>
            `;
      } else {
        upperRow.innerHTML = `
                <td rowspan="2" style="background-color: #f8f8f8; font-weight: bold; ${cellStyle}">${i}A</td>
                <td class="score" id="original-score-${i}A" style="${cellStyle} border-bottom: none;">&nbsp;</td>
                <td class="compare-score compare-column" id="original-compare-score-${i}A" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
                <td class="compare2-score compare2-column" id="original-compare2-score-${i}A" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
                <td class="guaranteed-score guaranteed-column" id="original-guaranteed-score-${i}A" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
                <td class="guaranteed-compare-score guaranteed-compare-column" id="original-guaranteed-compare-score-${i}A" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
                <td class="guaranteed-compare2-score guaranteed-compare2-column" id="original-guaranteed-compare2-score-${i}A" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
                <td class="cat b-side-start" id="original-cat-${i - 1}B" style="${cellStyle} border-top: none;">&nbsp;</td>
                <td class="compare-cat compare-column" id="original-compare-cat-${i - 1}B" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
                <td class="compare2-cat compare2-column" id="original-compare2-cat-${i - 1}B" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
                <td class="guaranteed-cat guaranteed-column" id="original-guaranteed-cat-${i - 1}B" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
                <td class="guaranteed-compare-cat guaranteed-compare-column" id="original-guaranteed-compare-cat-${i - 1}B" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
                <td class="guaranteed-compare2-cat guaranteed-compare2-column" id="original-guaranteed-compare2-cat-${i - 1}B" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
            `;
      }
      tbody.appendChild(upperRow);

      // 下の行（キャラ行）
      const lowerRow = document.createElement('tr');
      lowerRow.innerHTML = `
            <td class="cat" id="original-cat-${i}A" style="${cellStyle} border-top: none;">&nbsp;</td>
            <td class="compare-cat compare-column" id="original-compare-cat-${i}A" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
            <td class="compare2-cat compare2-column" id="original-compare2-cat-${i}A" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
            <td class="guaranteed-cat guaranteed-column" id="original-guaranteed-cat-${i}A" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
            <td class="guaranteed-compare-cat guaranteed-compare-column" id="original-guaranteed-compare-cat-${i}A" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
            <td class="guaranteed-compare2-cat guaranteed-compare2-column" id="original-guaranteed-compare2-cat-${i}A" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
            <td class="score b-side-start" id="original-score-${i}B" style="${cellStyle} border-bottom: none;">&nbsp;</td>
            <td class="compare-score compare-column" id="original-compare-score-${i}B" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
            <td class="compare2-score compare2-column" id="original-compare2-score-${i}B" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
            <td class="guaranteed-score guaranteed-column" id="original-guaranteed-score-${i}B" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
            <td class="guaranteed-compare-score guaranteed-compare-column" id="original-guaranteed-compare-score-${i}B" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
            <td class="guaranteed-compare2-score guaranteed-compare2-column" id="original-guaranteed-compare2-score-${i}B" style="${cellStyle} border-bottom: none; display: none;">&nbsp;</td>
            <td rowspan="2" style="background-color: #f8f8f8; font-weight: bold; ${cellStyle}">${i}B</td>
        `;
      tbody.appendChild(lowerRow);
    }

    // 最後のB側キャット行
    const finalRow = document.createElement('tr');
    finalRow.innerHTML = `
        <td class="empty-colspan" colspan="6" style="${cellStyle}">&nbsp;</td>
        <td class="cat b-side-start" id="original-cat-${count}B" style="${cellStyle} border-top: none;">&nbsp;</td>
        <td class="compare-cat compare-column" id="original-compare-cat-${count}B" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
        <td class="compare2-cat compare2-column" id="original-compare2-cat-${count}B" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
        <td class="guaranteed-cat guaranteed-column" id="original-guaranteed-cat-${count}B" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
        <td class="guaranteed-compare-cat guaranteed-compare-column" id="original-guaranteed-compare-cat-${count}B" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
        <td class="guaranteed-compare2-cat guaranteed-compare2-column" id="original-guaranteed-compare2-cat-${count}B" style="${cellStyle} border-top: none; display: none;">&nbsp;</td>
    `;
    tbody.appendChild(finalRow);

    return tbody;
  }

  // オリジナルテーブルを削除
  function removeOriginalTable() {
    const customContainer = document.querySelector('.custom-table-container');
    if (customContainer) {
      customContainer.remove();
    }
  }
  // 確定列の表示/非表示切り替え
  function toggleGuaranteedColumns() {
    const currentGachaEleven = elementCache.get('current_gacha_eleven');
    const compareGachaEleven = elementCache.get('compare_gacha_eleven');
    const compareGacha2Eleven = elementCache.get('compare_gacha2_eleven');
    const compareGachaSingle = elementCache.get('compare_gacha_single');
    const compareGacha2Single = elementCache.get('compare_gacha2_single');

    if (!currentGachaEleven || !compareGachaEleven || !compareGacha2Eleven || !compareGachaSingle || !compareGacha2Single) return;

    // 被り確認用ガチャ①
    const compareColumns = document.querySelectorAll('.compare-column');
    compareColumns.forEach((column) => {
      column.style.display = compareGachaKey && compareGachaSingle.checked ? 'table-cell' : 'none';
    });

    // 被り確認用ガチャ②
    const compare2Columns = document.querySelectorAll('.compare2-column');
    compare2Columns.forEach((column) => {
      column.style.display = compareGachaKey2 && compareGacha2Single.checked ? 'table-cell' : 'none';
    });

    // 確定列の制御
    const guaranteedColumns = document.querySelectorAll('.guaranteed-column');
    const guaranteedCompareColumns = document.querySelectorAll('.guaranteed-compare-column');
    const guaranteedCompare2Columns = document.querySelectorAll('.guaranteed-compare2-column');

    guaranteedColumns.forEach((column) => {
      column.style.display = currentGachaEleven.checked ? 'table-cell' : 'none';
    });

    guaranteedCompareColumns.forEach((column) => {
      column.style.display = compareGachaKey && compareGachaEleven.checked ? 'table-cell' : 'none';
    });

    guaranteedCompare2Columns.forEach((column) => {
      column.style.display = compareGachaKey2 && compareGacha2Eleven.checked ? 'table-cell' : 'none';
    });

    // colspanを動的に変更
    updateColspans();

    // 計画モードが有効な場合、クリックイベントを再適用
    if (isPlanMode) {
      attachClickEventsToAllCells();
    }
  }
  // colspanを動的に変更
  function updateColspans() {
    const compareGachaSingle = elementCache.get('compare_gacha_single');
    const compareGacha2Single = elementCache.get('compare_gacha2_single');
    const currentGachaEleven = elementCache.get('current_gacha_eleven');
    const compareGachaEleven = elementCache.get('compare_gacha_eleven');
    const compareGacha2Eleven = elementCache.get('compare_gacha2_eleven');

    if (!compareGachaSingle || !compareGacha2Single || !currentGachaEleven || !compareGachaEleven || !compareGacha2Eleven) return;

    let colspan = 2; // 基本の現在のガチャ

    // 被り確認用ガチャが選択されており、かつチェックされている場合のみカウント
    if (compareGachaKey && compareGachaSingle.checked) colspan++;
    if (compareGachaKey2 && compareGacha2Single.checked) colspan++;
    if (currentGachaEleven.checked) colspan++;
    if (compareGachaKey && compareGachaEleven.checked) colspan++;
    if (compareGachaKey2 && compareGacha2Eleven.checked) colspan++;

    // empty-colspanを動的に変更
    const emptyColspans = document.querySelectorAll('.empty-colspan');
    emptyColspans.forEach((cell) => {
      cell.setAttribute('colspan', colspan);
    });
  }

  //==================== オリジナルテーブルデータ更新 ====================

  // オリジナルテーブルデータを更新
  function updateOriginalTableData() {
    // シード生成
    seedProcessor.generateAllSeedsOptimized(currentSeed, count);

    // 各ガチャの設定を取得
    const currentConfig = getGachaConfig(currentGachaKey, 'current');
    const compareConfig = compareGachaKey ? getGachaConfig(compareGachaKey, 'compare') : null;
    const compareConfig2 = compareGachaKey2 ? getGachaConfig(compareGachaKey2, 'compare2') : null;

    if (!currentConfig) return;

    // チェックボックスの状態を取得
    const compareGachaSingle = elementCache.get('compare_gacha_single');
    const compareGacha2Single = elementCache.get('compare_gacha2_single');

    // 列表示制御を先に実行
    toggleGuaranteedColumns();

    // 非同期バッチ処理で更新
    updateTableDataAsync(currentConfig, compareConfig, compareConfig2, compareGachaSingle?.checked && compareGachaKey, compareGacha2Single?.checked && compareGachaKey2);
  }
  // 非同期でテーブルデータを更新
  async function updateTableDataAsync(currentConfig, compareConfig, compareConfig2, showCompare, showCompare2) {
    const BATCH_SIZE = 100; // 一度に処理する行数
    const updates = [];
    const rerollTargets = [];

    // 全データを計算（バッチ処理）
    for (let batchStart = 1; batchStart <= count; batchStart += BATCH_SIZE) {
      const batchEnd = Math.min(batchStart + BATCH_SIZE - 1, count);

      for (let i = batchStart; i <= batchEnd; i++) {
        const resultA = calculateTableCellData(`${i}A`, currentConfig, compareConfig, compareConfig2, '', showCompare, showCompare2);
        const resultB = calculateTableCellData(`${i}B`, currentConfig, compareConfig, compareConfig2, '', showCompare, showCompare2);

        updates.push([`${i}A`, resultA], [`${i}B`, resultB]);

        if (resultA?.current?.isReRollAgain && resultA?.current?.consecutiveRare) {
          rerollTargets.push(resultA.current);
        }
        if (resultB?.current?.isReRollAgain && resultB?.current?.consecutiveRare) {
          rerollTargets.push(resultB.current);
        }
      }

      // バッチ間で少し待機（UIのブロックを防ぐ）
      if (batchEnd < count) {
        await new Promise((resolve) => setTimeout(resolve, 1));
      }
    }

    // 再評価ループ
    let reRollAgainTargets = [];
    while (rerollTargets.length > 0) {
      const currentTargets = [...rerollTargets];
      reRollAgainTargets = [...rerollTargets, ...reRollAgainTargets];
      rerollTargets.length = 0;

      for (const targetDetail of currentTargets) {
        const result = calculateTableCellData(targetDetail.nextTableNumber, currentConfig, compareConfig, compareConfig2, targetDetail.nextCharacter, showCompare, showCompare2);

        const existingUpdate = updates.find(([tableNum]) => tableNum === targetDetail.nextTableNumber);
        if (existingUpdate) {
          existingUpdate[1] = result;
        } else {
          updates.push([targetDetail.nextTableNumber, result]);
        }

        if (result?.current?.isReRollAgain && result?.current?.consecutiveRare) {
          rerollTargets.push(result.current);
        }
      }
    }

    // DOM更新を非同期バッチ処理
    await batchUpdateTableCellsAsync(updates);

    // 確定列の処理
    updateGuaranteedColumns(reRollAgainTargets);

    // ハイライト機能を追加
    applyOriginalTableHighlights();

    // 計画モードが有効な場合、クリックイベントを再適用
    if (isPlanMode) {
      attachClickEventsToAllCells();
    }
  }

  // 非同期バッチ処理でテーブルセルを更新
  async function batchUpdateTableCellsAsync(updates) {
    const BATCH_SIZE = 200; // 一度に処理するセル数

    for (let batchStart = 0; batchStart < updates.length; batchStart += BATCH_SIZE) {
      const batchEnd = Math.min(batchStart + BATCH_SIZE, updates.length);
      const batch = updates.slice(batchStart, batchEnd);

      // バッチ処理実行
      batch.forEach(([tableNumber, data]) => {
        if (!data) return;

        // 現在のガチャセルを更新
        if (data.current) {
          updateCellContent(`original-cat-${tableNumber}`, data.current, 'original-');
          updateCellContent(`original-score-${tableNumber}`, data.current, 'original-', true);
        }

        // 被り確認用ガチャのセルを更新
        if (data.compare) {
          updateCellContent(`original-compare-cat-${tableNumber}`, data.compare, 'original-compare-');
          updateCellContent(`original-compare-score-${tableNumber}`, data.compare, 'original-compare-', true);
        } else {
          clearCell(`original-compare-cat-${tableNumber}`);
          clearCell(`original-compare-score-${tableNumber}`);
        }

        if (data.compare2) {
          updateCellContent(`original-compare2-cat-${tableNumber}`, data.compare2, 'original-compare2-');
          updateCellContent(`original-compare2-score-${tableNumber}`, data.compare2, 'original-compare2-', true);
        } else {
          clearCell(`original-compare2-cat-${tableNumber}`);
          clearCell(`original-compare2-score-${tableNumber}`);
        }
      });

      // バッチ間で少し待機（UIのレスポンシブ性を保つ）
      if (batchEnd < updates.length) {
        await new Promise((resolve) => requestAnimationFrame(resolve));
      }
    }
  }

  // テーブルセルデータを計算
  function calculateTableCellData(tableNumber, currentConfig, compareConfig, compareConfig2, rerollChar = '', showCompare = false, showCompare2 = false) {
    const indexes = getTableIndexes(tableNumber);
    if (!indexes || indexes[0] >= seedProcessor.allSeeds.length || indexes[1] >= seedProcessor.allSeeds.length) {
      return null;
    }

    const currentDetails = getSlotDetails(tableNumber, currentGachaKey, rerollChar, currentConfig);
    const compareDetails = showCompare && compareConfig ? getSlotDetails(tableNumber, compareGachaKey, rerollChar, compareConfig) : null;
    const compare2Details = showCompare2 && compareConfig2 ? getSlotDetails(tableNumber, compareGachaKey2, rerollChar, compareConfig2) : null;

    return {
      current: currentDetails,
      compare: compareDetails,
      compare2: compare2Details,
    };
  }

  // 一括DOM更新
  function batchUpdateTableCells(updates) {
    const fragment = document.createDocumentFragment();

    updates.forEach(([tableNumber, data]) => {
      if (!data) return;
      // 現在のガチャセルを更新
      if (data.current) {
        updateCellContent(`original-cat-${tableNumber}`, data.current, 'original-');
        updateCellContent(`original-score-${tableNumber}`, data.current, 'original-', true);
      }

      // 被り確認用ガチャのセルを更新
      if (data.compare) {
        updateCellContent(`original-compare-cat-${tableNumber}`, data.compare, 'original-compare-');
        updateCellContent(`original-compare-score-${tableNumber}`, data.compare, 'original-compare-', true);
      } else {
        clearCell(`original-compare-cat-${tableNumber}`);
        clearCell(`original-compare-score-${tableNumber}`);
      }

      if (data.compare2) {
        updateCellContent(`original-compare2-cat-${tableNumber}`, data.compare2, 'original-compare2-');
        updateCellContent(`original-compare2-score-${tableNumber}`, data.compare2, 'original-compare2-', true);
      } else {
        clearCell(`original-compare2-cat-${tableNumber}`);
        clearCell(`original-compare2-score-${tableNumber}`);
      }
    });
  }

  // セルをクリア
  function clearCell(cellId) {
    const cell = document.getElementById(cellId);
    if (cell) {
      cell.innerHTML = '&nbsp;';
      cell.style.backgroundColor = '';
      cell.style.color = '';
      cell.style.fontWeight = '';
      cell.style.cursor = '';
      cell.className = cell.className
        .split(' ')
        .filter((cls) => !cls.startsWith('rank-'))
        .join(' ');
    }
  }

  // セルスタイリングを適用
  function applyCellStyling(cell, details, prefix) {
    cell.className = `${prefix.includes('compare2') ? 'compare2-cat compare2-column' : prefix.includes('compare') ? 'compare-cat compare-column' : 'cat'} rank-${details.rank}`;

    if (details.bgColor) {
      cell.style.setProperty('background-color', details.bgColor, 'important');
      if (details.color) {
        const span = cell.querySelector('span');
        if (span) {
          span.style.setProperty('color', details.color, 'important');
        }
      }
    } else {
      applyRankStyling(cell, details.rank);
    }
  }

  // セル内容を更新
  function updateCellContent(cellId, details, prefix, isScoreCell = false) {
    const cell = document.getElementById(cellId);
    if (!cell || !details) return;

    if (details.consecutiveRare && !isScoreCell) {
      if (details.nextTableNumber.endsWith('B')) {
        cell.innerHTML = `<span class="next-char-click" data-next-seed="${details.nextSeed}">${details.nextCharacter} -> ${details.nextTableNumber}${details.isReRollAgain ? 'R' : ''}</span>`;
      } else {
        cell.innerHTML = `<span class="next-char-click" data-next-seed="${details.nextSeed}"><- ${details.nextTableNumber}${details.isReRollAgain ? 'R' : ''} ${details.nextCharacter}</span>`;
      }
    } else if (details.consecutiveRare && isScoreCell) {
      cell.innerHTML = `<span class="char-click" data-char-seed="${details.charSeed}">${details.character}</span>`;
    } else if (!isScoreCell) {
      cell.innerHTML = `<span class="char-click" data-char-seed="${details.charSeed}">${details.character}</span>`;
    } else {
      cell.innerHTML = '&nbsp;';
    }

    // スタイル適用
    applyCellStyling(cell, details, prefix);
    addCharClickEvents(cell, null);
  }

  // 確定列を更新
  function updateGuaranteedColumns(reRollAgainTargets) {
    const currentGachaEleven = elementCache.get('current_gacha_eleven');
    const compareGachaEleven = elementCache.get('compare_gacha_eleven');
    const compareGacha2Eleven = elementCache.get('compare_gacha2_eleven');

    if (!currentGachaEleven || !compareGachaEleven || !compareGacha2Eleven) return;

    const currentConfig = getGachaConfig(currentGachaKey, 'current');
    const compareConfig = compareGachaKey ? getGachaConfig(compareGachaKey, 'compare') : null;
    const compareConfig2 = compareGachaKey2 ? getGachaConfig(compareGachaKey2, 'compare2') : null;

    if (!currentConfig) return;

    // 一括処理用の配列
    const updates = [];

    // DocumentFragmentを使用してDOM操作を最適化
    const fragment = document.createDocumentFragment();

    for (let i = 1; i <= count; i++) {
      const tableA = `${i}A`;
      const tableB = `${i}B`;

      // 現在のガチャの確定列
      if (currentGachaEleven.checked) {
        updates.push({ type: 'current', table: tableA, config: currentConfig });
        updates.push({ type: 'current', table: tableB, config: currentConfig });
      }

      // 被り確認用ガチャ①の確定列
      if (compareGachaEleven.checked && compareConfig) {
        updates.push({ type: 'compare', table: tableA, config: compareConfig });
        updates.push({ type: 'compare', table: tableB, config: compareConfig });
      }

      // 被り確認用ガチャ②の確定列
      if (compareGacha2Eleven.checked && compareConfig2) {
        updates.push({ type: 'compare2', table: tableA, config: compareConfig2 });
        updates.push({ type: 'compare2', table: tableB, config: compareConfig2 });
      }
    }

    // 一括処理実行
    batchUpdateGuaranteedCells(updates);

    // reRollAgainTargetsの処理も最適化
    if (reRollAgainTargets.length > 0) {
      const rerollUpdates = [];
      reRollAgainTargets.forEach((target) => {
        if (currentGachaEleven.checked && target.gachaKey === currentGachaKey) {
          rerollUpdates.push({ type: 'current', table: target.nextTableNumber, config: currentConfig, isReroll: true });
        } else if (compareGachaEleven.checked && compareConfig && target.gachaKey === compareGachaKey) {
          rerollUpdates.push({ type: 'compare', table: target.nextTableNumber, config: compareConfig, isReroll: true });
        } else if (compareGacha2Eleven.checked && compareConfig2 && target.gachaKey === compareGachaKey2) {
          rerollUpdates.push({ type: 'compare2', table: target.nextTableNumber, config: compareConfig2, isReroll: true });
        }
      });
      batchUpdateGuaranteedCells(rerollUpdates);
    }
  }
  // 確定列の一括更新関数
  function batchUpdateGuaranteedCells(updates) {
    // バッチサイズを設定（一度に処理するセル数）
    const BATCH_SIZE = 100;
    let currentBatch = 0;

    function processBatch() {
      const start = currentBatch * BATCH_SIZE;
      const end = Math.min(start + BATCH_SIZE, updates.length);

      for (let i = start; i < end; i++) {
        const update = updates[i];
        const prefix = getGuaranteedPrefix(update.type);

        if (update.config) {
          updateGuaranteedCell(
            update.table,
            update.config,
            prefix,
            update.type === 'current' ? currentGachaKey : update.type === 'compare' ? compareGachaKey : compareGachaKey2,
            update.isReroll || false,
          );
        } else {
          clearGuaranteedCells(update.table, prefix);
        }
      }

      currentBatch++;

      // 次のバッチがある場合は非同期で処理
      if (end < updates.length) {
        requestAnimationFrame(processBatch);
      }
    }

    // 初回実行
    processBatch();
  }
  function getGuaranteedPrefix(type) {
    switch (type) {
      case 'compare':
        return 'original-guaranteed-compare-';
      case 'compare2':
        return 'original-guaranteed-compare2-';
      default:
        return 'original-guaranteed-';
    }
  }
  // ガチャセルをクリア
  function clearGachaCells(tableNumber, prefix) {
    const catCell = document.getElementById(`${prefix}cat-${tableNumber}`);
    const scoreCell = document.getElementById(`${prefix}score-${tableNumber}`);

    if (catCell) {
      catCell.innerHTML = '&nbsp;';
      catCell.style.backgroundColor = '';
      catCell.style.color = '';
      catCell.style.fontWeight = '';
      catCell.style.cursor = '';
      catCell.className = catCell.className
        .split(' ')
        .filter((cls) => !cls.startsWith('rank-'))
        .join(' ');
    }
    if (scoreCell) {
      scoreCell.innerHTML = '&nbsp;';
      scoreCell.style.backgroundColor = '';
      scoreCell.style.color = '';
      scoreCell.style.fontWeight = '';
      scoreCell.style.cursor = '';
      scoreCell.className = scoreCell.className
        .split(' ')
        .filter((cls) => !cls.startsWith('rank-'))
        .join(' ');
    }
  }

  // 確定セルをクリア
  function clearGuaranteedCells(tableNumber, prefix) {
    const guaranteedCatCell = document.getElementById(`${prefix}cat-${tableNumber}`);
    const guaranteedScoreCell = document.getElementById(`${prefix}score-${tableNumber}`);

    if (guaranteedCatCell) {
      guaranteedCatCell.innerHTML = '&nbsp;';
      guaranteedCatCell.style.backgroundColor = '';
      guaranteedCatCell.style.color = '';
    }
    if (guaranteedScoreCell) {
      guaranteedScoreCell.innerHTML = '&nbsp;';
      guaranteedScoreCell.style.backgroundColor = '';
      guaranteedScoreCell.style.color = '';
    }
  }

  // ランク別スタイリング関数
  function applyRankStyling(cell, rank) {
    switch (rank) {
      case 'rare':
        cell.style.backgroundColor = 'white';
        cell.style.color = '';
        break;
      case 'super':
        cell.style.backgroundColor = 'gold';
        cell.style.color = '';
        break;
      case 'uber':
        cell.style.backgroundColor = 'red';
        cell.style.color = 'rgb(255, 255, 0)';
        break;
      case 'legend':
        cell.style.backgroundColor = 'darkviolet';
        cell.style.color = 'rgb(255, 255, 0)';
        break;
    }
  }

  // char-clickのクリックイベント
  function addCharClickEvents(catCell, scoreCell) {
    const cells = [catCell, scoreCell].filter((cell) => cell);

    cells.forEach((cell) => {
      const charClickElements = cell.querySelectorAll('.char-click, .next-char-click');
      charClickElements.forEach((element) => {
        element.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();

          // data-char-seedまたはdata-next-seedを取得
          const seed = this.dataset.charSeed || this.dataset.nextSeed;
          if (seed) {
            const currentUrl = new URL(window.location.href);
            currentUrl.searchParams.set('seed', seed);
            window.location.href = currentUrl.toString();
          }
        });
      });
    });
  }

  // 確定セルの更新
  function updateGuaranteedCell(tableNumber, config, prefix, gachaKey, isDupForced = false) {
    const guaranteedCatCell = document.getElementById(`${prefix}cat-${tableNumber}`);
    const guaranteedScoreCell = document.getElementById(`${prefix}score-${tableNumber}`);

    if (!guaranteedCatCell || !guaranteedScoreCell || !config) return;

    // 確定枠の計算
    const guaranteedDetails = getGuaranteedSlotDetails(tableNumber, gachaKey, config, isDupForced);
    if (!guaranteedDetails) return;

    if (guaranteedDetails.bgColor) {
      guaranteedCatCell.style.setProperty('background-color', guaranteedDetails.bgColor, 'important');
      guaranteedScoreCell.style.setProperty('background-color', guaranteedDetails.bgColor, 'important');
    } else {
      guaranteedCatCell.style.backgroundColor = 'white';
      guaranteedScoreCell.style.backgroundColor = 'white';
    }

    if (guaranteedDetails && guaranteedDetails.nextTableNumber) {
      if (guaranteedDetails.nextTableNumber2) {
        if (guaranteedDetails.consecutiveRare) {
          if (guaranteedDetails.nextTableNumber2.endsWith('B')) {
            guaranteedScoreCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed2}">${guaranteedDetails.character2} -> ${guaranteedDetails.nextTableNumber2}</span>`;
          } else {
            guaranteedScoreCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed2}"><- ${guaranteedDetails.nextTableNumber2} ${guaranteedDetails.character2}</span>`;
          }
        }
      }
      if (guaranteedDetails.nextTableNumber.endsWith('B')) {
        guaranteedCatCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed}">${guaranteedDetails.character} -> ${guaranteedDetails.nextTableNumber}</span>`;
      } else {
        guaranteedCatCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed}"><- ${guaranteedDetails.nextTableNumber} ${guaranteedDetails.character}</span>`;
      }
    }

    // クリックイベントを追加
    addCharClickEvents(guaranteedCatCell, guaranteedScoreCell);
  }

  const originalTableStyles = `
    .rank-rare {
        background-color: white;
    }
    .rank-super {
        background-color: gold !important;
    }
    .rank-uber {
        background-color: red !important;
        color: rgb(255, 255, 0) !important;
    }
    .rank-legend {
        background-color: darkviolet !important;
        color: rgb(255, 255, 0) !important;
    }
    .char-click {
        cursor: pointer;
        color: #275a90;
        text-decoration: underline;
        font-size: 14px;
    }
    .char-click:hover {
        color: #0056b3;
    }
    .next-char-click {
        cursor: pointer;
        color: #275a90;
        text-decoration: underline;
        font-size: 14px;
    }
    .next-char-click:hover {
        color: #a71e2a;
    }
    /* uber/legendの文字色 */
    .rank-uber .char-click,
    .rank-uber .next-char-click {
        color: rgb(255, 255, 0) !important;
    }
    .rank-legend .char-click,
    .rank-legend .next-char-click {
        color: rgb(255, 255, 0) !important;
    }
  /* スクロール時のヘッダー固定スタイル */
  .custom-table-container {
      scrollbar-width: thin;
      scrollbar-color: #888 #f1f1f1;
  }
  .custom-table-container::-webkit-scrollbar {
      width: 8px;
  }
  .custom-table-container::-webkit-scrollbar-track {
      background: #f1f1f1;
  }
  .custom-table-container::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
  }
  .custom-table-container::-webkit-scrollbar-thumb:hover {
      background: #555;
  }

  /* ヘッダー固定の核心部分 */
  .custom-table thead th {
      position: sticky !important;
      top: 0 !important;
      z-index: 1001 !important;
      background-color: rgb(44, 62, 80) !important;
  }

  /* iOS対応 */
  @supports (-webkit-touch-callout: none) {
      .custom-table thead th {
          position: -webkit-sticky !important;
          position: sticky !important;
          top: 0 !important;
          z-index: 1001 !important;
          -webkit-transform: translateZ(0) !important;
          transform: translateZ(0) !important;
      }
  }

  /* モバイル対応 */
  @media screen and (max-width: 768px) {
      .custom-table thead th {
          position: sticky !important;
          position: -webkit-sticky !important;
          top: 0 !important;
          z-index: 1001 !important;
          background-color: rgb(44, 62, 80) !important;
          -webkit-transform: translate3d(0,0,0) !important;
          transform: translate3d(0,0,0) !important;
          will-change: transform !important;
      }
  }
`;

  // スタイルを追加
  if (!document.getElementById('original-table-styles')) {
    const style = document.createElement('style');
    style.id = 'original-table-styles';
    style.textContent = originalTableStyles;
    document.head.appendChild(style);
  }

  // ==================== 色の説明更新 ====================
  // 色の説明を更新
  function updateColorLegend() {
    const colorLegendContent = document.getElementById('color_legend_content');
    if (!colorLegendContent) return;

    colorLegendContent.innerHTML = `
        <div style="display: flex; align-items: center; gap: 5px;">
            <div style="width: 20px; height: 20px; background-color: #ff0000; border-radius: 3px; border: 1px solid #ccc;"></div>
            <span>レア被り</span>
        </div>
        <div style="display: flex; align-items: center; gap: 5px;">
            <div style="width: 20px; height: 20px; background-color: #4a90e2; border-radius: 3px; border: 1px solid #ccc;"></div>
            <span>レアスコア昇格対象</span>
        </div>
    `;
  }

  // ==================== ハイライト機能 ====================
  // オリジナルテーブルハイライトを適用
  function applyOriginalTableHighlights() {
    // 事前に必要な要素を取得
    const customTable = document.querySelector('.custom-table');
    if (!customTable) return;

    const allTds = customTable.querySelectorAll('td');

    // レア該当インデックス取得の最適化
    const rates = [currentGachaKey, compareGachaKey, compareGachaKey2].filter((key) => key && GACHA_CONFIG[key]).map((key) => GACHA_CONFIG[key].rate[0]);

    if (rates.length === 0) return;

    const threshold = Math.max(...rates);
    const rareValidIndices = seedProcessor.getRareValidIndicesOptimized(threshold);
    const tableNumbers = rareValidIndices.map(indexToTableNumber);
    const consecutivePairs = findConsecutiveTablePairs(tableNumbers);
    const allCollisions = detectAllGachaCollisions(consecutivePairs);

    detectRareScorePromotions();

    // ハイライト処理をMap化して高速化
    const collisionMap = new Map();
    const allCollisionTables = new Set();

    allCollisions.forEach((collision) => {
      if (Array.isArray(collision)) {
        collision.forEach((table) => allCollisionTables.add(table));
      } else {
        allCollisionTables.add(collision);
      }
    });

    // 一括ハイライト処理
    allTds.forEach((td) => {
      const cellText = td.textContent.trim();

      // レア被りを優先
      if (allCollisionTables.has(cellText)) {
        applyHighlight(td, '#ff0000', '#ffffff', cellText, 'collision');
      } else if (rareScoreData.has(cellText)) {
        const rareScoreInfo = rareScoreData.get(cellText);
        applyHighlight(td, rareScoreInfo.color, '#ffffff', cellText, 'rarescore');
      }
    });
  }

  // ハイライト適用の共通化
  function applyHighlight(td, bgColor, textColor, cellText, type) {
    td.style.backgroundColor = bgColor;
    td.style.color = textColor;
    td.style.fontWeight = 'bold';
    td.style.cursor = 'pointer';

    if (type === 'collision') {
      addOriginalTableClickEvents(td, cellText);
    } else if (type === 'rarescore') {
      addOriginalTableRareScoreClickEvents(td, cellText);
    }
  }

  // オリジナルテーブル用クリックイベント（被り用）
  function addOriginalTableClickEvents(element, tableNumber) {
    const newElement = element.cloneNode(true);
    element.parentNode.replaceChild(newElement, element);

    newElement.addEventListener('click', function (e) {
      e.preventDefault();
      e.stopPropagation();

      const data = collisionData.get(tableNumber);
      if (!data) return;

      const message = `選択: ${data.currentTable} (${data.currentGachaName})
被り: ${data.collisionTable} (${data.collisionGachaName})
キャラクター: ${data.collisionChar}`;

      showModernPopup(message, newElement);
    });
  }

  // オリジナルテーブル用クリックイベント（レアスコア用）
  function addOriginalTableRareScoreClickEvents(element, tableNumber) {
    const newElement = element.cloneNode(true);
    element.parentNode.replaceChild(newElement, element);

    newElement.addEventListener('click', function (e) {
      e.preventDefault();
      e.stopPropagation();

      const data = rareScoreData.get(tableNumber);
      if (!data) return;

      const message = `${data.message}`;
      showModernPopup(message, newElement);
    });
  }

  // ハイライトをリセット
  function resetHighlights() {
    const existingModal = document.getElementById('detail-modal');
    if (existingModal) {
      existingModal.remove();
    }

    // 元のテーブルのハイライトをリセット
    const allTds = document.querySelectorAll('td');
    allTds.forEach((td) => {
      if (td.style.backgroundColor === 'rgb(255, 0, 0)' || td.style.backgroundColor === '#ff0000' || td.style.backgroundColor === '#4a90e2' || td.style.backgroundColor === 'rgb(74, 144, 226)') {
        const newTd = td.cloneNode(true);
        newTd.style.backgroundColor = '';
        newTd.style.color = '';
        newTd.style.fontWeight = '';
        newTd.style.cursor = '';
        td.parentNode.replaceChild(newTd, td);
      }
    });

    // ★ オリジナルテーブルのハイライトもリセット ★
    const customTable = document.querySelector('.custom-table');
    if (customTable) {
      const customTds = customTable.querySelectorAll('td');
      customTds.forEach((td) => {
        if (td.style.backgroundColor === 'rgb(255, 0, 0)' || td.style.backgroundColor === '#ff0000' || td.style.backgroundColor === '#4a90e2' || td.style.backgroundColor === 'rgb(74, 144, 226)') {
          const newTd = td.cloneNode(true);
          newTd.style.backgroundColor = '';
          newTd.style.color = '';
          newTd.style.fontWeight = '';
          newTd.style.cursor = '';
          td.parentNode.replaceChild(newTd, td);
        }
      });
    }

    collisionData.clear();
    rareScoreData.clear();
  }

  // レア被りをハイライト
  async function highlightRareCollisions() {
    console.time('全体処理時間');

    // 並列シード生成を試行、失敗時は従来方式
    try {
      await seedProcessor.generateSeedsParallel(currentSeed, count);
    } catch (error) {
      console.warn('並列処理失敗、従来方式で実行:', error);
      seedProcessor.generateAllSeedsOptimized(currentSeed, count);
    }

    // レア該当インデックス取得：存在するガチャの大きい方を取得
    const rates = [];
    if (GACHA_CONFIG[currentGachaKey]) {
      rates.push(GACHA_CONFIG[currentGachaKey].rate[0]);
    }
    if (compareGachaKey && GACHA_CONFIG[compareGachaKey]) {
      rates.push(GACHA_CONFIG[compareGachaKey].rate[0]);
    }
    if (compareGachaKey2 && GACHA_CONFIG[compareGachaKey2]) {
      rates.push(GACHA_CONFIG[compareGachaKey2].rate[0]);
    }

    const threshold = Math.max(...rates);
    const rareValidIndices = seedProcessor.getRareValidIndicesOptimized(threshold);

    // テーブル番号変換
    const tableNumbers = rareValidIndices.map((index) => indexToTableNumber(index));
    const consecutivePairs = findConsecutiveTablePairs(tableNumbers);

    // 被り検出
    const allCollisions = detectAllGachaCollisions(consecutivePairs);

    // レアスコア判定を追加
    detectRareScorePromotions();

    // ハイライト実行（レア被りを先、レアスコアは後）
    highlightCollisionCells(allCollisions);
    highlightRareScoreCells();

    // 色の説明を更新
    updateColorLegend();

    console.timeEnd('全体処理時間');
  }

  // 被りセルをハイライト
  function highlightCollisionCells(collisions) {
    const allTds = document.querySelectorAll('td');
    let highlightedCount = 0;

    // 全ての被りテーブルを平坦化してユニークにする
    const allCollisionTables = new Set();
    collisions.forEach((collision) => {
      if (Array.isArray(collision)) {
        collision.forEach((table) => allCollisionTables.add(table));
      } else {
        allCollisionTables.add(collision);
      }
    });

    allTds.forEach((td) => {
      const cellText = td.textContent.trim();
      if (allCollisionTables.has(cellText)) {
        td.style.backgroundColor = '#ff0000';
        td.style.color = '#ffffff';
        td.style.fontWeight = 'bold';
        td.style.cursor = 'pointer';
        addClickEvents(td, cellText);
        highlightedCount++;
      }
    });
  }

  // uber,legend色の変更
  function applyUberLegendStyling() {
    // uberクラスのtdの下にあるa要素のcolorを変更
    const uberTds = document.querySelectorAll('td.uber');
    uberTds.forEach((td) => {
      const aElement = td.querySelector('a');
      if (aElement) {
        aElement.style.color = 'rgb(255, 255, 0)';
      }
    });

    // legendクラスのtdの下にあるa要素のcolorを変更
    const legendTds = document.querySelectorAll('td.legend');
    legendTds.forEach((td) => {
      const aElement = td.querySelector('a');
      if (aElement) {
        aElement.style.color = 'rgb(255, 255, 0)';
      }
    });
  }

  // ==================== シード保存機能 ====================
  // ローカルストレージから保存済みシードを取得
  function getSavedSeeds() {
    const saved = localStorage.getItem('nyanko-saved-seeds');
    return saved ? JSON.parse(saved) : [];
  }

  // シード保存処理
  function handleSaveSeed() {
    if (currentSeed) {
      const seeds = saveSeed(currentSeed);
      const seedList = document.getElementById('seed-list');
      if (seedList) {
        updateSeedList(seedList, seeds);
      }
      alert(`シード "${currentSeed}" を保存しました`);
    } else {
      alert('シードが見つかりません');
    }
  }

  // シードを保存（日時付きで最大10件まで）
  function saveSeed(seed) {
    let seeds = getSavedSeeds();
    const now = new Date();
    const dateStr = `(${String(now.getFullYear()).slice(-2)}/${String(now.getMonth() + 1).padStart(2, '0')}/${String(now.getDate()).padStart(2, '0')})`;
    const seedData = seed + dateStr;

    if (!seeds.includes(seedData)) {
      seeds.unshift(seedData);
      if (seeds.length > 10) {
        seeds = seeds.slice(0, 10);
      }
      localStorage.setItem('nyanko-saved-seeds', JSON.stringify(seeds));
    }
    return seeds;
  }

  // 指定したシードを削除
  function deleteSeed(seed) {
    let seeds = getSavedSeeds();
    seeds = seeds.filter((s) => s !== seed);
    localStorage.setItem('nyanko-saved-seeds', JSON.stringify(seeds));
    return seeds;
  }

  // 指定したシードのURLに遷移
  function navigateToSeed(seed) {
    const url = new URL(window.location);
    // 日時部分を削除してシードのみ抽出
    const cleanSeed = seed.replace(/\(.*?\)/g, '');
    url.searchParams.set('seed', cleanSeed);
    window.location.href = url.toString();
  }

  // シードリストのUIを更新
  function updateSeedList(container, seeds) {
    container.innerHTML = '';

    if (seeds.length === 0) {
      const noSeedsMsg = document.createElement('span');
      noSeedsMsg.textContent = '保存済みのシードはありません';
      noSeedsMsg.style.cssText = `
            color: #666;
            font-style: italic;
            font-size: 14px;
        `;
      container.appendChild(noSeedsMsg);
      return;
    }

    seeds.forEach((seed) => {
      const seedButtonContainer = document.createElement('div');
      seedButtonContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 4px;
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 4px;
            padding: 2px 6px;
            margin: 0px;
        `;

      const seedButton = document.createElement('button');
      seedButton.textContent = seed;
      seedButton.style.cssText = `
            background: transparent;
            border: none;
            padding: 4px 12px;
            margin: 0px;
            font-size: 15px;
            cursor: pointer;
            color: #1976d2;
            font-family: monospace;
            transition: background-color 0.2s;
            border-radius: 2px;
        `;

      seedButton.onmouseover = () => {
        seedButton.style.backgroundColor = 'rgba(25, 118, 210, 0.1)';
      };
      seedButton.onmouseout = () => {
        seedButton.style.backgroundColor = 'transparent';
      };
      seedButton.onclick = () => {
        navigateToSeed(seed);
      };

      const deleteButton = document.createElement('button');
      deleteButton.textContent = '×';
      deleteButton.style.cssText = `
            background: #f44336;
            color: white;
            border: none;
            border-radius: 3px;
            width: 20px;
            height: 18px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            margin: 0px;
            padding:0px;
        `;

      deleteButton.onmouseover = () => {
        deleteButton.style.backgroundColor = '#d32f2f';
      };
      deleteButton.onmouseout = () => {
        deleteButton.style.backgroundColor = '#f44336';
      };
      deleteButton.onclick = (e) => {
        e.stopPropagation();
        if (confirm(`シード "${seed}" を削除しますか？`)) {
          const updatedSeeds = deleteSeed(seed);
          updateSeedList(container, updatedSeeds);
        }
      };

      seedButtonContainer.appendChild(seedButton);
      seedButtonContainer.appendChild(deleteButton);
      container.appendChild(seedButtonContainer);
    });
  }
  // ==================== ポップアップ機能 ====================

  // モダンポップアップを表示
  function showModernPopup(message, targetElement) {
    const existingPopup = document.querySelector('.star-popup');
    if (existingPopup) {
      existingPopup.remove();
    }

    const popup = document.createElement('div');
    popup.className = 'star-popup';
    popup.style.cssText = `
            position: absolute;
            background: #2c3e50;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.4;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 10001;
            max-width: 280px;
            white-space: pre-line;
            border: 1px solid #34495e;
            backdrop-filter: blur(10px);
            animation: slideIn 0.2s ease-out;
        `;

    const closeButton = document.createElement('button');
    closeButton.innerHTML = '×';
    closeButton.style.cssText = `
            position: absolute;
            top: 4px;
            right: 8px;
            background: none;
            border: none;
            color: #ecf0f1;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: background-color 0.2s;
        `;

    closeButton.onmouseover = () => {
      closeButton.style.backgroundColor = 'rgba(231, 76, 60, 0.8)';
    };
    closeButton.onmouseout = () => {
      closeButton.style.backgroundColor = 'transparent';
    };
    closeButton.onclick = (e) => {
      e.stopPropagation();
      popup.remove();
    };

    const messageContainer = document.createElement('div');
    messageContainer.style.cssText = `
            padding-right: 24px;
            font-weight: 500;
        `;
    messageContainer.textContent = message;

    popup.appendChild(closeButton);
    popup.appendChild(messageContainer);
    document.body.appendChild(popup);

    // 位置計算
    const targetRect = targetElement.getBoundingClientRect();
    const popupRect = popup.getBoundingClientRect();
    let top = targetRect.top - popupRect.height - 10;
    let left = targetRect.left + targetRect.width / 2 - popupRect.width / 2;

    if (top < 10) {
      top = targetRect.bottom + 10;
    }
    if (left < 10) {
      left = 10;
    } else if (left + popupRect.width > window.innerWidth - 10) {
      left = window.innerWidth - popupRect.width - 10;
    }

    popup.style.top = `${top + window.scrollY}px`;
    popup.style.left = `${left}px`;

    setTimeout(() => {
      if (popup && popup.parentNode) {
        popup.remove();
      }
    }, 5000);

    const handleOutsideClick = (e) => {
      if (!popup.contains(e.target)) {
        popup.remove();
        document.removeEventListener('click', handleOutsideClick);
      }
    };
    setTimeout(() => {
      document.addEventListener('click', handleOutsideClick);
    }, 100);
  }

  // クリックイベントを追加
  function addClickEvents(element, tableNumber) {
    const newElement = element.cloneNode(true);
    element.parentNode.replaceChild(newElement, element);

    newElement.addEventListener('click', function (e) {
      e.preventDefault();
      e.stopPropagation();

      const data = collisionData.get(tableNumber);
      if (!data) return;

      const message = `選択: ${data.currentTable} (${data.currentGachaName})
被り: ${data.collisionTable} (${data.collisionGachaName})
キャラクター: ${data.collisionChar}`;

      showModernPopup(message, newElement);
    });
  }

  // ==================== 計画モード ====================
  if (!document.getElementById('plan-mode-style')) {
    const style = document.createElement('style');
    style.id = 'plan-mode-style';
    style.textContent = `
        /* 計画モード時はリンクを無効化 */
        .plan-mode .char-click,
        .plan-mode .next-char-click {
            pointer-events: none !important;
            text-decoration: none !important;
            cursor: default !important;
        }

        /* テーブル位置全体の選択スタイル - catセルは上枠なし */
        .selected-table-position.cat-cell {
            box-shadow: inset 3px 0 0 #228B22, inset -3px 0 0 #228B22, inset 0 -3px 0 #228B22 !important;
            background-color: #98fb98 !important;
            color: black !important;
        }

        /* テーブル位置全体の選択スタイル - scoreセルは下枠なし */
        .selected-table-position.score-cell {
            box-shadow: inset 3px 0 0 #228B22, inset -3px 0 0 #228B22, inset 0 3px 0 #228B22 !important;
            background-color: #98fb98 !important;
            color: black !important;
        }

        /* 確定列選択スタイル - catセルは上枠なし */
        .selected-guaranteed-table-position.cat-cell {
            box-shadow: inset 3px 0 0 #e91e63, inset -3px 0 0 #e91e63, inset 0 -3px 0 #e91e63 !important;
            background-color: #fce4ec !important;
            color: black !important;
        }

        /* 確定列選択スタイル - scoreセルは下枠なし */
        .selected-guaranteed-table-position.score-cell {
            box-shadow: inset 3px 0 0 #e91e63, inset -3px 0 0 #e91e63, inset 0 3px 0 #e91e63 !important;
            background-color: #fce4ec !important;
            color: black !important;
        }

        /* uber/legend文字色の調整 - 赤色で太文字 */
        .selected-table-position.uber-legend-text,
        .selected-guaranteed-table-position.uber-legend-text {
            color: red !important;
            font-weight: bold !important;
        }

        .selected-table-position.uber-legend-text *,
        .selected-guaranteed-table-position.uber-legend-text * {
            color: red !important;
            font-weight: bold !important;
        }

        /* 通常の選択されたテーブル位置内の文字色 */
        .selected-table-position:not(.uber-legend-text) *,
        .selected-guaranteed-table-position:not(.uber-legend-text) * {
            color: black !important;
        }
        /* 確定列によって影響を受けるセルのスタイル - catセルは上枠なし */
        .affected-by-guaranteed.cat-cell {
            box-shadow: inset 3px 0 0 #ff69b4, inset -3px 0 0 #ff69b4, inset 0 -3px 0 #ff69b4 !important;
            background-color: #ffe0f0 !important;
            color: black !important;
            cursor: not-allowed !important;
            pointer-events: none !important;
        }

        /* 確定列によって影響を受けるセルのスタイル - scoreセルは下枠なし */
        .affected-by-guaranteed.score-cell {
            box-shadow: inset 3px 0 0 #ff69b4, inset -3px 0 0 #ff69b4, inset 0 3px 0 #ff69b4 !important;
            background-color: #ffe0f0 !important;
            color: black !important;
            cursor: not-allowed !important;
            pointer-events: none !important;
        }

        /* 影響を受けるセル内の文字色 */
        .affected-by-guaranteed:not(.uber-legend-text) * {
            color: black !important;
        }
        /* 影響を受けるセルでuber/legendの文字色 */
        .affected-by-guaranteed.uber-legend-text,
        .affected-by-guaranteed.uber-legend-text * {
            color: red !important;
            font-weight: bold !important;
        }
        /* 青色の確定列選択スタイル - catセルは上枠なし */
        .selected-guaranteed-table-position-blue.cat-cell {
            box-shadow: inset 3px 0 0 #2196f3, inset -3px 0 0 #2196f3, inset 0 -3px 0 #2196f3 !important;
            background-color: #e3f2fd !important;
            color: black !important;
        }

        /* 青色の確定列選択スタイル - scoreセルは下枠なし */
        .selected-guaranteed-table-position-blue.score-cell {
            box-shadow: inset 3px 0 0 #2196f3, inset -3px 0 0 #2196f3, inset 0 3px 0 #2196f3 !important;
            background-color: #e3f2fd !important;
            color: black !important;
        }

        /* 青色選択でのuber/legend文字色 */
        .selected-guaranteed-table-position-blue.uber-legend-text,
        .selected-guaranteed-table-position-blue.uber-legend-text * {
            color: red !important;
            font-weight: bold !important;
        }

        /* 青色選択での通常文字色 */
        .selected-guaranteed-table-position-blue:not(.uber-legend-text) *,
        .selected-guaranteed-table-position-blue:not(.uber-legend-text) * {
            color: black !important;
        }
       /* 確定列によって影響を受けるセルの青色スタイル - catセルは上枠なし */
        .affected-by-guaranteed-blue.cat-cell {
            box-shadow: inset 3px 0 0 #2196f3, inset -3px 0 0 #2196f3, inset 0 -3px 0 #2196f3 !important;
            background-color: #e3f2fd !important;
            color: black !important;
            cursor: not-allowed !important;
            pointer-events: none !important;
        }

        /* 確定列によって影響を受けるセルの青色スタイル - scoreセルは下枠なし */
        .affected-by-guaranteed-blue.score-cell {
            box-shadow: inset 3px 0 0 #2196f3, inset -3px 0 0 #2196f3, inset 0 3px 0 #2196f3 !important;
            background-color: #e3f2fd !important;
            color: black !important;
            cursor: not-allowed !important;
            pointer-events: none !important;
        }

        /* 青色影響セル内の文字色 */
        .affected-by-guaranteed-blue:not(.uber-legend-text) * {
            color: black !important;
        }

        /* 青色影響セルでuber/legendの文字色 */
        .affected-by-guaranteed-blue.uber-legend-text,
        .affected-by-guaranteed-blue.uber-legend-text * {
            color: red !important;
            font-weight: bold !important;
        }
    `;
    document.head.appendChild(style);
  }
  // チケットカウンターを作成する関数
  function createTicketCounter() {
    const existingCounter = document.getElementById('ticket-counter');
    if (existingCounter) {
      existingCounter.remove();
    }

    const counter = document.createElement('div');
    counter.id = 'ticket-counter';

    const updateResponsiveStyle = () => {
      if (window.innerWidth <= 768) {
        counter.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background-color: #ffffffee;
                border: none;
                border-top: 1px solid #007bff;
                padding: 12px 16px;
                border-radius: 0;
                font-size: 16px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 -2px 12px rgba(0, 0, 0, 0.15);
                backdrop-filter: blur(6px);
                color: #333;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                display: flex;
                flex-direction: row;
                gap: 16px;
                align-items: center;
                justify-content: center;
                width: 100%;
                box-sizing: border-box;
                overflow: hidden;
                min-width: 100vw;
            `;
      } else {
        counter.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background-color: #ffffffee;
                border: 1px solid #007bff;
                padding: 12px 16px;
                border-radius: 8px;
                font-size: 16px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                backdrop-filter: blur(6px);
                color: #333;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                display: flex;
                flex-direction: row;
                gap: 16px;
                min-width: 200px;
                align-items: center;
                justify-content: center;
            `;
      }
    };

    counter.innerHTML = `
        <div>レアチケ：<span id="rare-count">0</span></div>
        <div>猫缶：<span id="catfood-count">0</span></div>
    `;

    document.body.appendChild(counter);

    updateResponsiveStyle();
    window.addEventListener('resize', updateResponsiveStyle);

    // スマホ用CSS
    if (!document.getElementById('mobile-ticket-counter-style')) {
      const style = document.createElement('style');
      style.id = 'mobile-ticket-counter-style';
      style.textContent = `
            @media screen and (max-width: 768px) {
                #ticket-counter {
                    position: fixed !important;
                    bottom: 0 !important;
                    left: 0 !important;
                    right: 0 !important;
                    width: 100% !important;
                    min-width: 100vw !important;
                    transform: none !important;
                    -webkit-transform: none !important;
                    z-index: 9999 !important;
                    margin: 0 !important;
                }

                /* ページのコンテンツがカウンターの下に隠れないようにするための余白 */
                body {
                    padding-bottom: 60px;
                }

                /* スクロール時も固定されるように追加のスタイル */
                #ticket-counter {
                    -webkit-backface-visibility: hidden;
                    backface-visibility: hidden;
                    will-change: transform;
                }
            }
        `;
      document.head.appendChild(style);
    }
  }

  // チケットカウント表示を更新
  function updateTicketDisplay() {
    const rareCountElement = document.getElementById('rare-count');
    const catfoodCountElement = document.getElementById('catfood-count');

    if (rareCountElement) rareCountElement.textContent = ticketCounts.rare;
    if (catfoodCountElement) catfoodCountElement.textContent = ticketCounts.catfood;
  }
  // 計画モードの切り替え
  function togglePlanMode() {
    const customTable = document.querySelector('.custom-table');

    if (isPlanMode) {
      // 計画モードを有効化
      if (customTable) {
        customTable.classList.add('plan-mode');
      }
      createTicketCounter();
      ticketCounts = { rare: 0, catfood: 0 };
      selectedTablePositions.clear();
      updateTicketDisplay();
      addPlanModeClickEvents();
      updateCellClickability();
    } else {
      // 通常モードに戻す
      if (customTable) {
        customTable.classList.remove('plan-mode');
      }
      removeTicketCounter();
      removePlanModeClickEvents();
      clearAllSelections();
      selectedTablePositions.clear();
    }
  }

  // チケットカウンターを削除
  function removeTicketCounter() {
    const counter = document.getElementById('ticket-counter');
    if (counter) {
      counter.remove();
    }

    // スマホ用のスタイル削除
    const mobileStyle = document.getElementById('mobile-ticket-counter-style');
    if (mobileStyle) {
      mobileStyle.remove();
    }

    // padding-bottom リセット
    if (window.innerWidth <= 768) {
      document.body.style.paddingBottom = '';
    }
  }

  // 計画モード用のクリックイベントを追加
  function addPlanModeClickEvents() {
    const customTable = document.querySelector('.custom-table');
    if (!customTable) return;

    // 既存のイベントリスナーを削除
    removePlanModeClickEvents();

    // 動的に追加されたセルも含めて、全てのセルを対象にする
    attachClickEventsToAllCells();
  }

  // 全てのセルにクリックイベントを動的に追加
  function attachClickEventsToAllCells() {
    const customTable = document.querySelector('.custom-table');
    if (!customTable) return;

    // catセルとscoreセル両方を対象にする
    const allClickableCells = customTable.querySelectorAll('td[id*="cat-"], td[id*="score-"]');

    console.log('見つかったクリック可能セル数:', allClickableCells.length);

    allClickableCells.forEach((cell) => {
      const cellId = cell.id;

      // 確定列かどうかを判定
      const isGuaranteedCell = cellId.includes('guaranteed-');

      cell.style.cursor = 'pointer';

      // 既存のイベントリスナーを削除
      cell.removeEventListener('click', handleSingleCellClick);
      cell.removeEventListener('click', handleGuaranteedCellClick);
      cell.removeEventListener('click', handleAffectedCellClick);

      // 適切なイベントリスナーを追加
      if (isGuaranteedCell) {
        cell.addEventListener('click', handleGuaranteedCellClick);
      } else {
        cell.addEventListener('click', handleSingleCellClick);
      }
    });
  }

  // 単発セルのクリック処理
  function handleSingleCellClick(e) {
    if (!isPlanMode) return;

    e.preventDefault();
    e.stopPropagation();

    const cell = e.currentTarget;
    const cellInfo = getCellInfo(cell);

    if (!cellInfo) return;

    console.log(`単発クリック: ${cellInfo.gachaName} - ${cellInfo.columnType} - ${cellInfo.tablePosition}`);

    // 同じテーブル位置の両セルを取得
    const { catCell, scoreCell } = getTablePositionCells(cellInfo.tablePosition, cellInfo.gachaType, cellInfo.isGuaranteed);

    if (!catCell || !scoreCell) return;

    const isSelected = catCell.classList.contains('selected-table-position') || scoreCell.classList.contains('selected-table-position');

    // ガチャキーを取得
    const gachaKey = cellInfo.gachaType === 'compare' ? compareGachaKey : cellInfo.gachaType === 'compare2' ? compareGachaKey2 : currentGachaKey;

    // スロットのランクを取得
    const rank = getSlotRank(cellInfo.tablePosition, gachaKey, cellInfo.gachaType);
    const isUberLegend = rank === 'uber' || rank === 'legend';

    if (isSelected) {
      // 選択解除
      catCell.classList.remove('selected-table-position', 'cat-cell', 'uber-legend-text');
      scoreCell.classList.remove('selected-table-position', 'score-cell', 'uber-legend-text');
      selectedTablePositions.delete(cellInfo.tablePosition);
      selectedTablePositions.delete(toggleTableSuffix(cellInfo.tablePosition));
      ticketCounts.rare = Math.max(0, ticketCounts.rare - 1);
    } else {
      // 選択
      catCell.classList.add('selected-table-position', 'cat-cell');
      scoreCell.classList.add('selected-table-position', 'score-cell');
      selectedTablePositions.add(cellInfo.tablePosition);
      selectedTablePositions.add(toggleTableSuffix(cellInfo.tablePosition));

      if (isUberLegend) {
        catCell.classList.add('uber-legend-text');
        scoreCell.classList.add('uber-legend-text');
      }

      ticketCounts.rare += 1;
    }

    updateTicketDisplay();
    updateCellClickability();
  }

  // 確定セルのクリック処理
  function handleGuaranteedCellClick(e) {
    if (!isPlanMode) return;

    e.preventDefault();
    e.stopPropagation();

    const cell = e.currentTarget;
    const cellInfo = getCellInfo(cell);

    if (!cellInfo) return;

    // 確定列から単発列のテーブル位置を計算
    const gachaKey = cellInfo.gachaType === 'compare' ? compareGachaKey : cellInfo.gachaType === 'compare2' ? compareGachaKey2 : currentGachaKey;
    // 必要ネコ缶
    const catFoods = fifteenGuaranteedKeys.includes(gachaKey) ? 2100 : 1500;

    // 同じテーブル位置の両セル（確定列）を取得
    const { catCell, scoreCell } = getTablePositionCells(cellInfo.tablePosition, cellInfo.gachaType, cellInfo.isGuaranteed);

    if (!catCell || !scoreCell) return;

    // 現在の状態を判定
    const isPinkSelected = catCell.classList.contains('selected-guaranteed-table-position');
    const isBlueSelected = catCell.classList.contains('selected-guaranteed-table-position-blue');

    console.log(`確定クリック: ${cellInfo.gachaName} - ${cellInfo.columnType} - ${cellInfo.tablePosition}`);

    // consecutiveRareを判定するためにスロット詳細を取得
    const config = getGachaConfig(gachaKey, cellInfo.gachaType);
    if (!config) return;
    const details = getSlotDetails(cellInfo.tablePosition, gachaKey, '', config);
    if (!details) return;

    if (isPinkSelected) {
      // ピンク状態から次の状態へ
      catCell.classList.remove('selected-guaranteed-table-position', 'cat-cell', 'uber-legend-text');
      scoreCell.classList.remove('selected-guaranteed-table-position', 'score-cell', 'uber-legend-text');

      if (details.consecutiveRare) {
        // consecutiveRare=true: ピンク→青
        catCell.classList.add('selected-guaranteed-table-position-blue', 'cat-cell', 'uber-legend-text');
        scoreCell.classList.add('selected-guaranteed-table-position-blue', 'score-cell', 'uber-legend-text');

        // 元の影響範囲をクリア
        const fullAffectedPositions = calculateGuaranteedTablePositions(cellInfo.tablePosition, gachaKey, false).tablePositions;
        clearAffectedCells(fullAffectedPositions, cellInfo.gachaType);
        fullAffectedPositions.forEach((pos) => {
          selectedTablePositions.delete(pos);
          selectedTablePositions.delete(toggleTableSuffix(pos));
        });

        // 青色状態での再計算・再表示
        recalculateAndUpdateCells(cellInfo.tablePosition, gachaKey, cellInfo.gachaType, config, true);

        // 新しい影響範囲を設定
        const singleAffectedPositions = calculateGuaranteedTablePositions(cellInfo.tablePosition, gachaKey, true).tablePositions;
        highlightAffectedCells(singleAffectedPositions, cellInfo.gachaType, true);
        singleAffectedPositions.forEach((pos) => {
          selectedTablePositions.add(pos);
          selectedTablePositions.add(toggleTableSuffix(pos));
        });
      } else {
        // consecutiveRare=false: ピンク→戻す
        const fullAffectedPositions = calculateGuaranteedTablePositions(cellInfo.tablePosition, gachaKey, false).tablePositions;
        fullAffectedPositions.forEach((pos) => {
          selectedTablePositions.delete(pos);
          selectedTablePositions.delete(toggleTableSuffix(pos));
        });
        clearAffectedCells(fullAffectedPositions, cellInfo.gachaType);

        // 元の状態に戻すための再計算・再表示
        recalculateAndUpdateCells(cellInfo.tablePosition, gachaKey, cellInfo.gachaType, config, true, true);

        ticketCounts.catfood = Math.max(0, ticketCounts.catfood - catFoods);
      }
    } else if (isBlueSelected) {
      // 青状態から次の状態へ
      catCell.classList.remove('selected-guaranteed-table-position-blue', 'cat-cell', 'uber-legend-text');
      scoreCell.classList.remove('selected-guaranteed-table-position-blue', 'score-cell', 'uber-legend-text');

      if (details.consecutiveRare) {
        // consecutiveRare=true: 青→戻す
        const singleAffectedPositions = calculateGuaranteedTablePositions(cellInfo.tablePosition, gachaKey, true).tablePositions;
        singleAffectedPositions.forEach((pos) => {
          selectedTablePositions.delete(pos);
          selectedTablePositions.delete(toggleTableSuffix(pos));
        });
        clearAffectedCells(singleAffectedPositions, cellInfo.gachaType);

        // 元の状態に戻すための再計算・再表示
        recalculateAndUpdateCells(cellInfo.tablePosition, gachaKey, cellInfo.gachaType, config, false, true);

        ticketCounts.catfood = Math.max(0, ticketCounts.catfood - catFoods);
      } else {
        // consecutiveRare=false: 青→ピンク
        catCell.classList.add('selected-guaranteed-table-position', 'cat-cell', 'uber-legend-text');
        scoreCell.classList.add('selected-guaranteed-table-position', 'score-cell', 'uber-legend-text');

        // 元の影響範囲をクリア
        const singleAffectedPositions = calculateGuaranteedTablePositions(cellInfo.tablePosition, gachaKey, true).tablePositions;
        clearAffectedCells(singleAffectedPositions, cellInfo.gachaType);
        singleAffectedPositions.forEach((pos) => {
          selectedTablePositions.delete(pos);
          selectedTablePositions.delete(toggleTableSuffix(pos));
        });

        // ピンク色状態での再計算・再表示
        recalculateAndUpdateCells(cellInfo.tablePosition, gachaKey, cellInfo.gachaType, config, false);

        // 新しい影響範囲（フル）を設定
        const fullAffectedPositions = calculateGuaranteedTablePositions(cellInfo.tablePosition, gachaKey, false).tablePositions;
        fullAffectedPositions.forEach((pos) => {
          selectedTablePositions.add(pos);
          selectedTablePositions.add(toggleTableSuffix(pos));
        });
        highlightAffectedCells(fullAffectedPositions, cellInfo.gachaType, false);
      }
    } else {
      // 未選択状態から初回選択（consecutiveRareで色を判定）
      const affectedPositions = calculateGuaranteedTablePositions(cellInfo.tablePosition, gachaKey, false).tablePositions;

      // 新規選択時のみ競合チェック
      const hasConflict = affectedPositions.some((pos) => {
        const customTable = document.querySelector('.custom-table');
        if (!customTable) return false;

        const otherSelections = customTable.querySelectorAll(`
                td[id*="cat-${pos}"].selected-table-position:not([id*="${cellInfo.gachaType === 'current' ? '' : cellInfo.gachaType === 'compare' ? 'compare-' : 'compare2-'}"]),
                td[id*="score-${pos}"].selected-table-position:not([id*="${cellInfo.gachaType === 'current' ? '' : cellInfo.gachaType === 'compare' ? 'compare-' : 'compare2-'}"]),
                td[id*="cat-${pos}"].selected-guaranteed-table-position:not([id*="${cellInfo.gachaType === 'current' ? 'guaranteed-' : cellInfo.gachaType === 'compare' ? 'guaranteed-compare-' : 'guaranteed-compare2-'}"]),
                td[id*="score-${pos}"].selected-guaranteed-table-position:not([id*="${cellInfo.gachaType === 'current' ? 'guaranteed-' : cellInfo.gachaType === 'compare' ? 'guaranteed-compare-' : 'guaranteed-compare2-'}"])
            `);
        return otherSelections.length > 0;
      });

      if (hasConflict) {
        return;
      }

      if (details.consecutiveRare) {
        // consecutiveRare=true: 最初はピンク色で選択
        catCell.classList.add('selected-guaranteed-table-position', 'cat-cell', 'uber-legend-text');
        scoreCell.classList.add('selected-guaranteed-table-position', 'score-cell', 'uber-legend-text');

        // ピンク色状態での再計算・再表示
        recalculateAndUpdateCells(cellInfo.tablePosition, gachaKey, cellInfo.gachaType, config, false);

        // 影響するテーブル位置をセットに追加
        affectedPositions.forEach((pos) => {
          selectedTablePositions.add(pos);
          selectedTablePositions.add(toggleTableSuffix(pos));
        });

        // 影響を受ける単発列のセルをピンク色にする
        highlightAffectedCells(affectedPositions, cellInfo.gachaType, false);
      } else {
        // consecutiveRare=false: 最初は青色で選択
        catCell.classList.add('selected-guaranteed-table-position-blue', 'cat-cell', 'uber-legend-text');
        scoreCell.classList.add('selected-guaranteed-table-position-blue', 'score-cell', 'uber-legend-text');

        // 青色状態での再計算・再表示
        recalculateAndUpdateCells(cellInfo.tablePosition, gachaKey, cellInfo.gachaType, config, true);

        // 影響するテーブル位置をセットに追加
        const singleAffectedPositions = calculateGuaranteedTablePositions(cellInfo.tablePosition, gachaKey, true).tablePositions;
        singleAffectedPositions.forEach((pos) => {
          selectedTablePositions.add(pos);
          selectedTablePositions.add(toggleTableSuffix(pos));
        });

        // 影響を受ける単発列のセルを青色にする
        highlightAffectedCells(singleAffectedPositions, cellInfo.gachaType, true);
      }

      ticketCounts.catfood += catFoods;
    }

    updateTicketDisplay();
    updateCellClickability(); // クリック可能性を更新
  }
  // 確定列選択時の再計算・再表示関数
  function recalculateAndUpdateCells(tablePosition, gachaKey, gachaType, config, isBlue, isReset = false) {
    console.log(`再計算開始: ${tablePosition}, ${gachaType}, isBlue: ${isBlue}, isReset: ${isReset}`);

    // 影響を受ける単発列の再計算
    const result = calculateGuaranteedTablePositions(tablePosition, gachaKey, isBlue);
    const affectedPositions = result.tablePositions;
    const guaranteedIndex = result.guaranteedIndex;
    const result2 = calculateGuaranteedTablePositions(tablePosition, gachaKey, !isBlue);
    const coloredPositions = result2.tablePositions;
    const guaranteedIndex2 = result2.guaranteedIndex;

    resetSpecificCells(tablePosition, coloredPositions, gachaType, gachaKey, config);
    if (isReset) {
      return;
    }

    // 確定列の再計算
    if (isBlue) {
      // 青色状態
      updateGuaranteedCellForBlueState(tablePosition, guaranteedIndex, gachaKey, gachaType, config);
      let prevCharacter = '';
      affectedPositions.forEach((position, i) => {
        if (i === 0) {
          const details = updateSingleCellForPlanMode(position, gachaKey, gachaType, config, false, prevCharacter, true);
          prevCharacter = details.rank === 'rare' ? details.character : '';
        } else {
          const details = updateSingleCellForPlanMode(position, gachaKey, gachaType, config, false, prevCharacter, false);
          prevCharacter = details.rank === 'rare' ? (details.consecutiveRare ? details.nextCharacter : details.character) : '';
        }
      });
    } else {
      // ピンク色状態
      updateGuaranteedCellForPinkState(tablePosition, guaranteedIndex, guaranteedIndex2, gachaKey, gachaType, config);
      let prevCharacter = '';
      affectedPositions.forEach((position, i) => {
        if (i === 0) {
          const details = updateSingleCellForPlanMode(position, gachaKey, gachaType, config, true, prevCharacter, false);
          prevCharacter = details.rank === 'rare' ? details.nextCharacter : '';
        } else {
          const details = updateSingleCellForPlanMode(position, gachaKey, gachaType, config, false, prevCharacter, false);
          prevCharacter = details.rank === 'rare' ? (details.consecutiveRare ? details.nextCharacter : details.character) : '';
        }
      });
    }
  }
  function resetSpecificCells(guaranteedTablePosition, affectedPositions, gachaType, gachaKey, config) {
    let isFirstConsecutiveRare = false;
    // 影響を受けた単発列セルをリセット
    affectedPositions.forEach((position, i) => {
      const result = resetSingleCell(position, gachaKey, gachaType);
      if (i === 0) isFirstConsecutiveRare = result.consecutiveRare;
    });
    // 確定列セルをリセット
    resetGuaranteedCell(guaranteedTablePosition, gachaType, isFirstConsecutiveRare);
  }
  function resetGuaranteedCell(tablePosition, gachaType, isDupForced = false) {
    const guaranteedCatCell = document.getElementById(`original-guaranteed-${gachaType === 'current' ? '' : gachaType === 'compare' ? 'compare-' : 'compare2-'}cat-${tablePosition}`);
    const guaranteedScoreCell = document.getElementById(`original-guaranteed-${gachaType === 'current' ? '' : gachaType === 'compare' ? 'compare-' : 'compare2-'}score-${tablePosition}`);

    if (!guaranteedCatCell || !guaranteedScoreCell) return;

    // 元の確定列データを再計算
    const gachaKey = gachaType === 'compare' ? compareGachaKey : gachaType === 'compare2' ? compareGachaKey2 : currentGachaKey;
    const config = getGachaConfig(gachaKey, gachaType);

    if (!config) return;

    // 通常の確定列計算を実行
    const guaranteedDetails = getGuaranteedSlotDetails(tablePosition, gachaKey, config, isDupForced);
    if (!guaranteedDetails) return;

    // セル内容を元に戻す
    if (guaranteedDetails.nextTableNumber2 && guaranteedDetails.consecutiveRare) {
      if (guaranteedDetails.nextTableNumber2.endsWith('B')) {
        guaranteedScoreCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed2}">${guaranteedDetails.character2} -> ${guaranteedDetails.nextTableNumber2}</span>`;
      } else {
        guaranteedScoreCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed2}"><- ${guaranteedDetails.nextTableNumber2} ${guaranteedDetails.character2}</span>`;
      }
    } else {
      guaranteedScoreCell.innerHTML = '&nbsp;';
    }

    if (guaranteedDetails.nextTableNumber.endsWith('B')) {
      guaranteedCatCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed}">${guaranteedDetails.character} -> ${guaranteedDetails.nextTableNumber}</span>`;
    } else {
      guaranteedCatCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed}"><- ${guaranteedDetails.nextTableNumber} ${guaranteedDetails.character}</span>`;
    }

    // 背景色を元に戻す
    if (guaranteedDetails.bgColor) {
      guaranteedCatCell.style.setProperty('background-color', guaranteedDetails.bgColor, 'important');
      guaranteedScoreCell.style.setProperty('background-color', guaranteedDetails.bgColor, 'important');
    } else {
      guaranteedCatCell.style.backgroundColor = 'white';
      guaranteedScoreCell.style.backgroundColor = 'white';
    }

    // クリックイベントを再追加
    addCharClickEvents(guaranteedCatCell, guaranteedScoreCell);
  }

  // 単発列セルを元の状態にリセット
  function resetSingleCell(tablePosition, gachaKey, gachaType) {
    const prefix = gachaType === 'compare' ? 'original-compare-' : gachaType === 'compare2' ? 'original-compare2-' : 'original-';

    const catCell = document.getElementById(`${prefix}cat-${tablePosition}`);
    const scoreCell = document.getElementById(`${prefix}score-${tablePosition}`);

    if (!catCell || !scoreCell) return;

    // 元の設定で単発セルの詳細を再計算（再評価ループ込み）
    const config = getGachaConfig(gachaKey, gachaType);
    if (!config) return;

    // 再評価ループを実行して正確な状態を取得
    const correctDetails = calculateCorrectCellState(tablePosition, config, gachaType);
    if (!correctDetails) return;

    // セル内容を正確な状態に戻す
    updateCellContent(`${prefix}cat-${tablePosition}`, correctDetails, prefix);
    updateCellContent(`${prefix}score-${tablePosition}`, correctDetails, prefix, true);

    return correctDetails;
  }

  // 再評価ループを実行して正確なセル状態を計算
  function calculateCorrectCellState(targetTablePosition, config, gachaType) {
    // 現在のガチャ設定を取得
    const currentConfig = config;
    const compareConfig = gachaType === 'compare' && compareGachaKey ? getGachaConfig(compareGachaKey, 'compare') : null;
    const compareConfig2 = gachaType === 'compare2' && compareGachaKey2 ? getGachaConfig(compareGachaKey2, 'compare2') : null;

    // チェックボックスの状態を取得
    const compareGachaSingle = document.getElementById('compare_gacha_single');
    const compareGacha2Single = document.getElementById('compare_gacha2_single');

    const updates = [];
    const rerollTargets = [];

    // 全テーブル位置を計算（影響範囲を特定するため）
    for (let i = 1; i <= count; i++) {
      const resultA = calculateTableCellData(
        `${i}A`,
        currentConfig,
        compareConfig,
        compareConfig2,
        '',
        compareGachaSingle?.checked && compareGachaKey,
        compareGacha2Single?.checked && compareGachaKey2,
      );
      const resultB = calculateTableCellData(
        `${i}B`,
        currentConfig,
        compareConfig,
        compareConfig2,
        '',
        compareGachaSingle?.checked && compareGachaKey,
        compareGacha2Single?.checked && compareGachaKey2,
      );

      updates.push([`${i}A`, resultA], [`${i}B`, resultB]);

      if (resultA?.current?.isReRollAgain && resultA?.current?.consecutiveRare) {
        rerollTargets.push(resultA.current);
      }
      if (resultB?.current?.isReRollAgain && resultB?.current?.consecutiveRare) {
        rerollTargets.push(resultB.current);
      }
    }

    // 再評価ループ
    while (rerollTargets.length > 0) {
      const currentTargets = [...rerollTargets];
      rerollTargets.length = 0;

      for (const targetDetail of currentTargets) {
        const result = calculateTableCellData(
          targetDetail.nextTableNumber,
          currentConfig,
          compareConfig,
          compareConfig2,
          targetDetail.nextCharacter,
          compareGachaSingle?.checked && compareGachaKey,
          compareGacha2Single?.checked && compareGachaKey2,
        );

        const existingUpdate = updates.find(([tableNum]) => tableNum === targetDetail.nextTableNumber);
        if (existingUpdate) {
          existingUpdate[1] = result;
        } else {
          updates.push([targetDetail.nextTableNumber, result]);
        }

        if (result?.current?.isReRollAgain && result?.current?.consecutiveRare) {
          rerollTargets.push(result.current);
        }
      }
    }

    // 対象テーブル位置の正確な状態を取得
    const targetUpdate = updates.find(([tableNum]) => tableNum === targetTablePosition);
    if (!targetUpdate) return null;

    // ガチャタイプに応じて適切なデータを返す
    switch (gachaType) {
      case 'current':
        return targetUpdate[1]?.current;
      case 'compare':
        return targetUpdate[1]?.compare;
      case 'compare2':
        return targetUpdate[1]?.compare2;
      default:
        return null;
    }
  }
  // 青色状態の確定列セル更新
  function updateGuaranteedCellForBlueState(tablePosition, guaranteedIndex, gachaKey, gachaType, config) {
    const guaranteedCatCell = document.getElementById(`original-guaranteed-${gachaType === 'current' ? '' : gachaType === 'compare' ? 'compare-' : 'compare2-'}cat-${tablePosition}`);
    const guaranteedScoreCell = document.getElementById(`original-guaranteed-${gachaType === 'current' ? '' : gachaType === 'compare' ? 'compare-' : 'compare2-'}score-${tablePosition}`);

    if (!guaranteedCatCell || !guaranteedScoreCell) return;

    // 確定列を計算
    const guaranteedDetails = getSingleGuaranteedSlotDetails(tablePosition, guaranteedIndex, gachaKey, config, true);
    if (!guaranteedDetails) return;

    guaranteedScoreCell.innerHTML = ``;
    if (guaranteedDetails.nextTableNumber.endsWith('B')) {
      guaranteedCatCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed}">${guaranteedDetails.character} -> ${guaranteedDetails.nextTableNumber}</span>`;
    } else {
      guaranteedCatCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed}"><- ${guaranteedDetails.nextTableNumber} ${guaranteedDetails.character}</span>`;
    }

    // クリックイベントを追加
    addCharClickEvents(guaranteedCatCell, guaranteedScoreCell);
  }

  // ピンク色状態の確定列セル更新
  function updateGuaranteedCellForPinkState(tablePosition, guaranteedIndex, guaranteedIndex2, gachaKey, gachaType, config) {
    const guaranteedCatCell = document.getElementById(`original-guaranteed-${gachaType === 'current' ? '' : gachaType === 'compare' ? 'compare-' : 'compare2-'}cat-${tablePosition}`);
    const guaranteedScoreCell = document.getElementById(`original-guaranteed-${gachaType === 'current' ? '' : gachaType === 'compare' ? 'compare-' : 'compare2-'}score-${tablePosition}`);

    if (!guaranteedCatCell || !guaranteedScoreCell) return;

    // レア被り対応の確定列を計算（既存のgetGuaranteedSlotDetailsを使用）
    const guaranteedDetails = getSingleGuaranteedSlotDetails(tablePosition, guaranteedIndex, gachaKey, config);
    const guaranteedDetails2 = getSingleGuaranteedSlotDetails(tablePosition, guaranteedIndex2, gachaKey, config);

    if (!guaranteedDetails) return;

    // セル内容を更新（既存ロジックと同様）
    if (guaranteedDetails.nextTableNumber.endsWith('B')) {
      guaranteedCatCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed}">${guaranteedDetails.character} -> ${guaranteedDetails.nextTableNumber}</span>`;
    } else {
      guaranteedCatCell.innerHTML = `<span class="next-char-click" data-next-seed="${guaranteedDetails.charSeed}"><- ${guaranteedDetails.nextTableNumber} ${guaranteedDetails.character}</span>`;
    }

    // クリックイベントを追加
    addCharClickEvents(guaranteedCatCell, guaranteedScoreCell);
  }

  // 計画モード用の単発セル更新
  function updateSingleCellForPlanMode(tablePosition, gachaKey, gachaType, config, isDupForced, prevRareCharacter, isNotDupForced) {
    const prefix = gachaType === 'compare' ? 'original-compare-' : gachaType === 'compare2' ? 'original-compare2-' : 'original-';

    const catCell = document.getElementById(`${prefix}cat-${tablePosition}`);
    const scoreCell = document.getElementById(`${prefix}score-${tablePosition}`);

    if (!catCell || !scoreCell) return;

    // 単発セルの詳細を再計算
    const details = getSlotDetails(tablePosition, gachaKey, '', config, isDupForced, prevRareCharacter, isNotDupForced);
    if (!details) return;

    // セル内容を更新
    updateCellContent(`${prefix}cat-${tablePosition}`, details, prefix);
    updateCellContent(`${prefix}score-${tablePosition}`, details, prefix, true);

    return details;
  }

  // 連ガチャ最終テーブル位置から確定枠を計算
  function getSingleGuaranteedSlotDetails(tablePosition, guaranteedIndex, gachaKey, config) {
    let i = 1;
    let calculateTableNumber = tablePosition;
    const guaranteedCount = fifteenGuaranteedKeys.includes(gachaKey) ? 15 : 11;
    //最後のテーブル位置から確定枠を再計算
    const charSeed = seedProcessor.allSeeds[guaranteedIndex];
    const guaranteedCharacters = config.characters[2];
    const charIndex = charSeed % guaranteedCharacters.length;
    const character = guaranteedCharacters[charIndex];

    const nextTableNumber = indexToTableNumber(guaranteedIndex + 1);
    return {
      charSeed,
      character,
      charIndex,
      gachaKey: gachaKey,
      nextTableNumber,
    };
  }
  // セルのクリック可能性を更新する関数
  function updateCellClickability() {
    const customTable = document.querySelector('.custom-table');
    if (!customTable) return;

    const allClickableCells = customTable.querySelectorAll('td[id*="cat-"], td[id*="score-"]');

    allClickableCells.forEach((cell) => {
      const cellInfo = getCellInfo(cell);
      if (!cellInfo) return;

      // 現在のセルが選択済みかどうか確認（青色状態も含む）
      const isCurrentCellSelected =
        cell.classList.contains('selected-table-position') ||
        cell.classList.contains('selected-guaranteed-table-position') ||
        cell.classList.contains('selected-guaranteed-table-position-blue') ||
        cell.classList.contains('affected-by-guaranteed') ||
        cell.classList.contains('affected-by-guaranteed-blue');

      if (selectedTablePositions.has(cellInfo.tablePosition) && !isCurrentCellSelected) {
        // 他の列で選択済みの場合は無効化
        cell.style.cursor = 'not-allowed';
        cell.style.opacity = '0.5';
        cell.style.pointerEvents = 'none';
      } else {
        // 選択可能な場合または現在選択中の場合（青色状態も含む）
        cell.style.cursor = 'pointer';
        cell.style.opacity = '1';
        cell.style.pointerEvents = 'auto';
      }
    });
  }
  // 影響を受けるセルをハイライトする関数
  function highlightAffectedCells(affectedPositions, gachaType, isBlue = true) {
    const gachaKey = gachaType === 'compare' ? compareGachaKey : gachaType === 'compare2' ? compareGachaKey2 : currentGachaKey;

    affectedPositions.forEach((position) => {
      const { catCell, scoreCell } = getTablePositionCells(position, gachaType, false);

      if (catCell && scoreCell) {
        const baseClass = isBlue ? 'affected-by-guaranteed-blue' : 'affected-by-guaranteed';
        catCell.classList.add(baseClass, 'cat-cell');
        scoreCell.classList.add(baseClass, 'score-cell');

        const rank = getSlotRank(position, gachaKey, gachaType);
        if (rank === 'uber' || rank === 'legend') {
          catCell.classList.add('uber-legend-text');
          scoreCell.classList.add('uber-legend-text');
        }

        catCell.addEventListener('click', handleAffectedCellClick);
        scoreCell.addEventListener('click', handleAffectedCellClick);
      }
    });
  }
  // 影響を受けるセルのハイライトをクリア
  function clearAffectedCells(affectedPositions, gachaType) {
    affectedPositions.forEach((position) => {
      const { catCell, scoreCell } = getTablePositionCells(position, gachaType, false);

      if (catCell && scoreCell) {
        catCell.classList.remove('affected-by-guaranteed', 'cat-cell', 'score-cell', 'uber-legend-text');
        scoreCell.classList.remove('affected-by-guaranteed', 'cat-cell', 'score-cell', 'uber-legend-text');
        catCell.classList.remove('affected-by-guaranteed-blue', 'cat-cell', 'score-cell', 'uber-legend-text');
        scoreCell.classList.remove('affected-by-guaranteed-blue', 'cat-cell', 'score-cell', 'uber-legend-text');

        // イベントリスナーを削除
        catCell.removeEventListener('click', handleAffectedCellClick);
        scoreCell.removeEventListener('click', handleAffectedCellClick);
      }
    });
  }

  // 影響を受けるセルのクリック処理
  function handleAffectedCellClick(e) {
    e.preventDefault();
    e.stopPropagation();
  }

  // 計画モードのクリックイベントを削除
  function removePlanModeClickEvents() {
    const customTable = document.querySelector('.custom-table');
    if (!customTable) return;

    // より包括的にセルを取得
    const allCells = customTable.querySelectorAll('.cat, .score');
    allCells.forEach((cell) => {
      cell.style.cursor = '';
      cell.removeEventListener('click', handleSingleCellClick);
      cell.removeEventListener('click', handleGuaranteedCellClick);
    });
  }

  // 全ての選択状態をクリア
  function clearAllSelections() {
    const customTable = document.querySelector('.custom-table');
    if (!customTable) return;

    const selectedCells = customTable.querySelectorAll(
      '.selected-table-position, .selected-guaranteed-table-position, .selected-guaranteed-table-position-blue, .affected-by-guaranteed, .affected-by-guaranteed-blue',
    );
    selectedCells.forEach((cell) => {
      cell.classList.remove(
        'selected-table-position',
        'selected-guaranteed-table-position',
        'selected-guaranteed-table-position-blue',
        'affected-by-guaranteed',
        'affected-by-guaranteed-blue',
        'cat-cell',
        'score-cell',
        'uber-legend-text',
      );

      // スタイルをリセット
      cell.style.cursor = '';
      cell.style.opacity = '';
      cell.style.pointerEvents = '';

      // 影響セルのイベントリスナーも削除
      cell.removeEventListener('click', handleAffectedCellClick);
    });

    // 全てのクリック可能セルのスタイルをリセット
    const allClickableCells = customTable.querySelectorAll('td[id*="cat-"], td[id*="score-"]');
    allClickableCells.forEach((cell) => {
      cell.style.cursor = '';
      cell.style.opacity = '';
      cell.style.pointerEvents = '';
    });

    selectedTablePositions.clear();
    ticketCounts = { rare: 0, catfood: 0 };
    updateTicketDisplay();
  }
  // セル情報を特定する関数
  function getCellInfo(cell) {
    const cellId = cell.id;
    if (!cellId) return null;

    let match;
    let isGuaranteed = false;
    let gachaType = 'current';
    let tablePosition = '';

    // 確定列のパターンをチェック
    if (cellId.includes('guaranteed-compare2-')) {
      match = cellId.match(/original-guaranteed-compare2-(?:cat|score)-(\d+[AB])/);
      isGuaranteed = true;
      gachaType = 'compare2';
      tablePosition = match ? match[1] : '';
    } else if (cellId.includes('guaranteed-compare-')) {
      match = cellId.match(/original-guaranteed-compare-(?:cat|score)-(\d+[AB])/);
      isGuaranteed = true;
      gachaType = 'compare';
      tablePosition = match ? match[1] : '';
    } else if (cellId.includes('guaranteed-')) {
      match = cellId.match(/original-guaranteed-(?:cat|score)-(\d+[AB])/);
      isGuaranteed = true;
      gachaType = 'current';
      tablePosition = match ? match[1] : '';
    }
    // 通常列のパターンをチェック
    else if (cellId.includes('compare2-')) {
      match = cellId.match(/original-compare2-(?:cat|score)-(\d+[AB])/);
      isGuaranteed = false;
      gachaType = 'compare2';
      tablePosition = match ? match[1] : '';
    } else if (cellId.includes('compare-')) {
      match = cellId.match(/original-compare-(?:cat|score)-(\d+[AB])/);
      isGuaranteed = false;
      gachaType = 'compare';
      tablePosition = match ? match[1] : '';
    } else {
      match = cellId.match(/original-(?:cat|score)-(\d+[AB])/);
      isGuaranteed = false;
      gachaType = 'current';
      tablePosition = match ? match[1] : '';
    }

    if (!tablePosition) {
      return null;
    }

    // ガチャ名を取得
    let gachaName;
    switch (gachaType) {
      case 'current':
        gachaName = GACHA_CONFIG[currentGachaKey]?.name || '現在のガチャ';
        break;
      case 'compare':
        gachaName = GACHA_CONFIG[compareGachaKey]?.name || '被り確認①';
        break;
      case 'compare2':
        gachaName = GACHA_CONFIG[compareGachaKey2]?.name || '被り確認②';
        break;
      default:
        gachaName = '不明';
    }

    return {
      gachaType,
      gachaName,
      isGuaranteed,
      tablePosition,
      columnType: isGuaranteed ? '確定列' : '単発列',
    };
  }

  // テーブル位置の両セルを取得し、適切なクラスを付与する関数
  function getTablePositionCells(tablePosition, gachaType, isGuaranteed) {
    const prefix = isGuaranteed
      ? gachaType === 'compare'
        ? 'original-guaranteed-compare-'
        : gachaType === 'compare2'
          ? 'original-guaranteed-compare2-'
          : 'original-guaranteed-'
      : gachaType === 'compare'
        ? 'original-compare-'
        : gachaType === 'compare2'
          ? 'original-compare2-'
          : 'original-';

    const catCell = document.getElementById(`${prefix}cat-${tablePosition}`);
    const scoreCell = document.getElementById(`${prefix}score-${tablePosition}`);

    return { catCell, scoreCell };
  }

  // スロットデータのランクを取得する関数
  function getSlotRank(tablePosition, gachaKey, gachaType) {
    const config = getGachaConfig(gachaKey, gachaType);
    if (!config) return null;

    const details = getSlotDetails(tablePosition, gachaKey, '', config);
    return details ? details.rank : null;
  }

  // 確定列から対応する単発列のテーブル位置を計算する関数
  function calculateGuaranteedTablePositions(tablePosition, gachaKey, isBlue = true) {
    const config = getGachaConfig(gachaKey, 'current'); // ガチャタイプに応じて適切に取得
    if (!config) return [];

    let i = 1;
    let calculateTableNumber = tablePosition;
    const guaranteedCount = fifteenGuaranteedKeys.includes(gachaKey) ? 15 : 11;
    const tablePositions = [calculateTableNumber]; // 最初のテーブル位置も含める
    let prevCharacter = '';
    let guaranteedIndex = 0;
    while (i < guaranteedCount - 1) {
      if (isBlue) {
        if (i === 1) {
          // テーブル位置から数字と文字を分離
          const match = tablePosition.match(/^(\d+)([AB])$/);
          if (!match) return [tablePosition];

          const num = parseInt(match[1]);
          const suffix = match[2];
          const details = getSlotDetails(calculateTableNumber, gachaKey, '', config, false, prevCharacter);
          if (!details) break;
          // 次の連番を生成
          calculateTableNumber = `${num + 1}${suffix}`;
          prevCharacter = details.character;
        } else {
          const details = getSlotDetails(calculateTableNumber, gachaKey, '', config, false, prevCharacter);
          if (!details) break;
          prevCharacter = details.rank === 'rare' ? (details.consecutiveRare ? details.nextCharacter : details.character) : '';
          calculateTableNumber = details.nextTableNumber;
        }
      } else {
        if (i === 1) {
          const details = getSlotDetails(calculateTableNumber, gachaKey, '', config, true);
          if (!details) break;
          prevCharacter = details.nextCharacter;
          calculateTableNumber = details.nextTableNumber;
        } else {
          const details = getSlotDetails(calculateTableNumber, gachaKey, '', config, false, prevCharacter);
          if (!details) break;
          prevCharacter = details.rank === 'rare' ? (details.consecutiveRare ? details.nextCharacter : details.character) : '';
          calculateTableNumber = details.nextTableNumber;
        }
      }

      tablePositions.push(calculateTableNumber);
      i++;
    }
    const details = getSlotDetails(calculateTableNumber, gachaKey, '', config, false, prevCharacter);
    prevCharacter = details.rank === 'rare' ? (details.consecutiveRare ? details.nextCharacter : details.character) : '';
    calculateTableNumber = details.nextTableNumber;
    const indexes = getTableIndexes(details.nextTableNumber);
    if (!indexes || indexes[0] >= seedProcessor.allSeeds.length || indexes[1] >= seedProcessor.allSeeds.length) {
      return null;
    }
    guaranteedIndex = indexes[0];
    return { tablePositions, guaranteedIndex };
  }

  // リセット前の確認
  function shouldResetWithAlert() {
    if (ticketCounts.rare > 0 || ticketCounts.catfood > 0) {
      const message = `選択状態がリセットされます。\n` + `レアチケ: ${ticketCounts.rare}枚\n` + `猫缶: ${ticketCounts.catfood}個\n\n` + `よろしいですか？`;
      return confirm(message);
    }
    return true;
  }
  // ==================== 初期化 ====================
  function init() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
          addGachaSelectionUI(); // UIを先に表示
          applyUberLegendStyling(); // uber・legendスタイリングを適用
          highlightRareCollisions(); // 後で計算実行
        }, 100);
      });
    } else {
      setTimeout(() => {
        addGachaSelectionUI(); // UIを先に表示
        applyUberLegendStyling(); // uber・legendスタイリングを適用
        highlightRareCollisions(); // 後で計算実行
      }, 100);
    }
  }

  init();
})();
